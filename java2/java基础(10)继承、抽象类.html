<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修java基础(10)继承、抽象类' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>java基础(10)继承、抽象类</center></div><div class='banquan'>原文出处:本文由博客园博主爱编程的小灰灰提供。<br/>
原文连接:https://www.cnblogs.com/liuhui0308/p/11631861.html</div><br>
    <h1>1. 继承</h1>
<h2>1.1 继承的概念</h2>
<p>在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。例如公司中的研发部员工和维护部员工都属于员工，程序中便可以描述为研发部员工和维护部员工继承自员工，同理，JavaEE工程师和Android工程师继承自研发部员工，而维网络维护工程师和硬件维护工程师继承自维护部员工。这些员工之间会形成一个继承体系，具体如下图所示。</p>
<p><img src="./images/java基础(10)继承、抽象类0.png" alt="" width="629" height="321" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;在Java中，类的继承是指在一个现有类的基础上去构建一个新的类，构建出来的新类被称作子类，现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。</p>
<h2>1.2 继承的格式&amp;使用</h2>
<p>在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</p>
<p class="a">格式：</p>
<blockquote>
<p class="a"><span style="color: #ff0000;">class 子类 extends 父类 {}</span></p>
</blockquote>
<p>接下来通过一个案例来学习子类是如何继承父类的，如下所示。Example01.java</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 定义员工类Employee
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Employee {
    String name; </span><span style="color: #008000;">//</span><span style="color: #008000;"> 定义name属性
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 定义员工的工作方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> work() {
        System.out.println(</span>"尽心尽力地工作"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 定义研发部员工类Developer 继承 员工类Employee
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">class</span> Developer <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Employee {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 定义一个打印name的方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> printName() {
        System.out.println(</span>"name=" +<span style="color: #000000;"> name);
    }
}

</span><span style="color: #008000;">/*</span><span style="color: #008000;">
 * 定义测试类
 </span><span style="color: #008000;">*/</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Example01 {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Developer d </span>= <span style="color: #0000ff;">new</span> Developer(); <span style="color: #008000;">//</span><span style="color: #008000;"> 创建一个研发部员工类对象</span>
        d.name = "小明"; <span style="color: #008000;">//</span><span style="color: #008000;"> 为该员工类的name属性进行赋值</span>
        d.printName(); <span style="color: #008000;">//</span><span style="color: #008000;"> 调用该员工的printName()方法</span>
        d.work(); <span style="color: #008000;">//</span><span style="color: #008000;"> 调用Developer类继承来的work()方法</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p class="Java">运行结果如下图所示。</p>
<p><img src="./images/java基础(10)继承、抽象类1.png" alt="" /></p>
<p class="Java">在上述代码中，Developer类通过extends关键字继承了Employee类，这样Developer类便是Employee类的子类。从运行结果不难看出，子类虽然没有定义name属性和work()方法，但是却能访问这两个成员。这就说明，子类在继承父类的时候，会自动拥有父类的成员。</p>
<h2>1.3 继承的好处&amp;注意事项</h2>
<p>继承的好处：</p>
<blockquote>
<p>1、继承的出现提高了代码的复用性，提高软件开发效率。</p>
<p>2、继承的出现让类与类之间产生了关系，提供了多态的前提。</p>
</blockquote>
<p class="Java">在类的继承中，需要注意一些问题，具体如下：</p>
<p class="Java">1、在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类，例如下面这种情况是不合法的。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A{} 
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> B{}
</span><span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> A,B{}  <span style="color: #008000;">//</span><span style="color: #008000;"> C类不可以同时继承A类和B类</span></code></pre>

<p class="a">2、多个类可以继承一个父类，例如下面这种情况是允许的。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A{}
</span><span style="color: #0000ff;">class</span> B <span style="color: #0000ff;">extends</span><span style="color: #000000;"> A{}
</span><span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> A{}   <span style="color: #008000;">//</span><span style="color: #008000;"> 类B和类C都可以继承类A</span></code></pre>

<p class="a">3、在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类，例如C类继承自B类，而B类又可以去继承A类，这时，C类也可称作A类的子类。下面这种情况是允许的。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> A{}
</span><span style="color: #0000ff;">class</span> B <span style="color: #0000ff;">extends</span> A{}   <span style="color: #008000;">//</span><span style="color: #008000;"> 类B继承类A，类B是类A的子类</span>
<span style="color: #0000ff;">class</span> C <span style="color: #0000ff;">extends</span> B{}   <span style="color: #008000;">//</span><span style="color: #008000;"> 类C继承类B，类C是类B的子类，同时也是类A的子类</span></code></pre>

<p>4、在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。例如上面的这种情况中，B类是A类的子类，同时又是C类的父类。</p>
<h2>1.4 继承-子父类中成员变量的特点</h2>
<p>了解了继承给我们带来的好处，提高了代码的复用性。继承让类与类或者说对象与对象之间产生了关系。那么，当继承出现后，类的成员之间产生了那些变化呢？</p>
<p>类的成员重点学习成员变量、成员方法的变化。</p>
<p>成员变量：如果子类父类中出现不同名的成员变量，这时的访问是没有任何问题。</p>
<p>看如下代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Fu中的成员变量。</span>
    <span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Zi中的成员变量</span>
    <span style="color: #0000ff;">int</span> num2 = 6<span style="color: #000000;">;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Zi中的成员方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show()
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问父类中的num</span>
        System.out.println("Fu num="+<span style="color: #000000;">num);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问子类中的num2</span>
        System.out.println("Zi num2="+<span style="color: #000000;">num2);
    }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo 
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) 
    {
        Zi z </span>= <span style="color: #0000ff;">new</span> Zi(); <span style="color: #008000;">//</span><span style="color: #008000;">创建子类对象</span>
        z.show(); <span style="color: #008000;">//</span><span style="color: #008000;">调用子类中的show方法</span>
<span style="color: #000000;">    }
}</span></code></pre>

<p>代码说明：Fu类中的成员变量是非私有的，子类中可以直接访问，若Fu类中的成员变量私有了，子类是不能直接访问的。</p>
<p>&nbsp;</p>
<p>当子父类中出现了同名成员变量时，在子类中若要访问父类中的成员变量，必须使用关键字super来完成。super用来表示当前对象中包含的父类对象空间的引用。super今天不做具体讲解，在后面会详细讲解。</p>
<blockquote>
<p class="a"><span style="color: #ff0000;">在子类中，访问父类中的成员变量格式：</span></p>
<p class="a"><span style="color: #ff0000;">super.父类中的成员变量</span></p>
</blockquote>
<p>看如下代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Fu中的成员变量。</span>
    <span style="color: #0000ff;">int</span> num = 5<span style="color: #000000;">;
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">Zi中的成员变量</span>
    <span style="color: #0000ff;">int</span> num = 6<span style="color: #000000;">;
    </span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show()
    {
        </span><span style="color: #008000;">//</span><span style="color: #008000;">子父类中出现了同名的成员变量时
        </span><span style="color: #008000;">//</span><span style="color: #008000;">在子类中需要访问父类中非私有成员变量时，需要使用super关键字
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问父类中的num</span>
        System.out.println("Fu num="+<span style="color: #0000ff;">super</span><span style="color: #000000;">.num);
        </span><span style="color: #008000;">//</span><span style="color: #008000;">访问子类中的num2</span>
        System.out.println("Zi num2="+<span style="color: #0000ff;">this</span><span style="color: #000000;">.num);
    }
}
</span><span style="color: #0000ff;">class</span><span style="color: #000000;"> Demo5 
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) 
    {
        Zi z </span>= <span style="color: #0000ff;">new</span> Zi(); <span style="color: #008000;">//</span><span style="color: #008000;">创建子类对象</span>
        z.show(); <span style="color: #008000;">//</span><span style="color: #008000;">调用子类中的show方法</span>
<span style="color: #000000;">    }
}</span></code></pre>

<h2>1.5 继承-子父类中成员方法特点-重写&amp;应用</h2>
<p class="a">子父类中成员方法的特点</p>
<p>当在程序中通过对象调用方法时，会先在子类中查找有没有对应的方法，若子类中存在就会执行子类中的方法，若子类中不存在就会执行父类中相应的方法。</p>
<p>看如下代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){
        System.out.println(</span>"Fu类中的show方法执行"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show2(){
        System.out.println(</span>"Zi类中的show2方法执行"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">public</span>  <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Zi z </span>= <span style="color: #0000ff;">new</span><span style="color: #000000;"> Zi();
        z.show(); </span><span style="color: #008000;">//</span><span style="color: #008000;">子类中没有show方法，但是可以找到父类方法去执行</span>
<span style="color: #000000;">        z.show2();
    }
}</span></code></pre>

<p class="a">成员方法特殊情况&mdash;&mdash;覆盖</p>
<p>子类中出现与父类一模一样的方法时，会出现覆盖操作，也称为override重写、复写或者覆盖。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show()
    {
        System.out.println(</span>"Fu show"<span style="color: #000000;">);
    }
}
</span><span style="color: #0000ff;">class</span> Zi <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu
{
    </span><span style="color: #008000;">//</span><span style="color: #008000;">子类复写了父类的show方法</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> show()
    {
        System.out.println(</span>"Zi show"<span style="color: #000000;">);
    }
}</span></code></pre>

<p class="a">方法重写（覆盖）的应用：</p>
<p>当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容。</p>
<p>举例：比如手机，当描述一个手机时，它具有发短信，打电话，显示来电号码功能，后期由于手机需要在来电显示功能中增加显示姓名和头像，这时可以重新定义一个类描述智能手机，并继承原有描述手机的类。并在新定义的类中覆盖来电显示功能，在其中增加显示姓名和头像功能。</p>
<blockquote>
<p class="a"><span style="color: #ff0000;">在子类中，访问父类中的成员方法格式：</span></p>
<p class="a"><span style="color: #ff0000;">super.父类中的成员方法();</span></p>
</blockquote>
<p>看如下代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Test {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #0000ff;">new</span><span style="color: #000000;"> NewPhone().showNum();
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">手机类</span>
<span style="color: #0000ff;">class</span><span style="color: #000000;"> Phone{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> sendMessage(){
        System.out.println(</span>"发短信"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> call(){
        System.out.println(</span>"打电话"<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showNum(){
        System.out.println(</span>"来电显示号码"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">智能手机类</span>
<span style="color: #0000ff;">class</span> NewPhone <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Phone{
    
    </span><span style="color: #008000;">//</span><span style="color: #008000;">覆盖父类的来电显示号码功能，并增加自己的显示姓名和图片功能</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> showNum(){
        </span><span style="color: #008000;">//</span><span style="color: #008000;">调用父类已经存在的功能使用super</span>
        <span style="color: #0000ff;">super</span><span style="color: #000000;">.showNum();
        </span><span style="color: #008000;">//</span><span style="color: #008000;">增加自己特有显示姓名和图片功能</span>
        System.out.println("显示来电姓名"<span style="color: #000000;">);
        System.out.println(</span>"显示头像"<span style="color: #000000;">);
    }
}</span></code></pre>

<h2>1.6 方法重写的注意事项</h2>
<p>重写需要注意的细节问题：</p>
<p class="a">子类方法覆盖父类方法，必须要保证权限大于等于父类权限。</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">class</span><span style="color: #000000;"> Fu(){    
</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> show(){}
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> method(){}
}
</span><span style="color: #0000ff;">class</span> Zi() <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Fu{
</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> show(){}  <span style="color: #008000;">//</span><span style="color: #008000;">编译运行没问题</span>
    <span style="color: #0000ff;">void</span> method(){}      <span style="color: #008000;">//</span><span style="color: #008000;">编译错误</span>
}</code></pre>

<p class="a">写法上稍微注意:必须一模一样:方法的返回值类型 方法名 参数列表都要一样。</p>
<p>总结：当一个类是另一个类中的一种时，可以通过继承，来继承属性与功能。如果父类具备的功能内容需要子类特殊定义时，进行方法重写。</p>
<h1>2. 抽象类</h1>
<h2>2.1 抽象类-产生</h2>
<p>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</p>
<p>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</p>
<p>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是<span style="color: #ff0000;">方法功能声明相同，但方法功能主体不同。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个抽象方法。</span></p>
<p>描述JavaEE工程师：行为：工作。</p>
<p>描述Android工程师：行为：工作。</p>
<p>JavaEE工程师和Android工程师之间有共性，可以进行向上抽取。抽取它们的所属共性类型：研发部员工。由于JavaEE工程师和Android工程师都具有工作功能，但是他们具体工作内容却不一样。这时在描述研发部员工时，发现了有些功能（工作）不具体，这些不具体的功能，需要在类中标识出来，通过java中的关键字abstract(抽象)。</p>
<p><span style="color: #ff0000;">当定义了抽象函数的类也必须被abstract关键字修饰，被abstract关键字修饰的类是抽象类。</span></p>
<h2>2.2 抽象类&amp;抽象方法的定义</h2>
<p>抽象方法定义的格式：</p>
<blockquote>
<p class="a"><span style="color: #ff0000;">public abstract 返回值类型 方法名(参数);</span></p>
</blockquote>
<p>抽象类定义的格式：</p>
<blockquote>
<p class="a"><span style="color: #ff0000;">abstract class 类名 {</span></p>
<p class="a"><span style="color: #ff0000;">}</span></p>
</blockquote>
<p>看如下代码：</p>
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;">研发部员工 </span>
<span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Developer {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">abstract</span> <span style="color: #0000ff;">void</span> work();<span style="color: #008000;">//</span><span style="color: #008000;">抽象函数。需要abstract修饰，并分号;结束</span>
<span style="color: #000000;">}

</span><span style="color: #008000;">//</span><span style="color: #008000;">JavaEE工程师</span>
<span style="color: #0000ff;">class</span> JavaEE <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Developer{
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> work() {
        System.out.println(</span>"正在研发淘宝网站"<span style="color: #000000;">);
    }
}

</span><span style="color: #008000;">//</span><span style="color: #008000;">Android工程师</span>
<span style="color: #0000ff;">class</span> Android <span style="color: #0000ff;">extends</span><span style="color: #000000;"> Developer {
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> work() {
        System.out.println(</span>"正在研发淘宝手机客户端软件"<span style="color: #000000;">);
    }
}</span></code></pre>

<h2>2.3 抽象类的特点：</h2>
<p>1、抽象类和抽象方法都需要被abstract修饰。抽象方法一定要定义在抽象类中。</p>
<p>2、抽象类不可以直接创建对象，原因：调用抽象方法没有意义。</p>
<p>3、只有覆盖了抽象类中所有的抽象方法后，其子类才可以创建对象。否则该子类还是一个抽象类。</p>
<p>之所以继承抽象类，更多的是在思想，是面对共性类型操作会更简单。</p>
<h2>2.4 抽象类的细节问题：</h2>
<p>1、抽象类一定是个父类？&nbsp;</p>
<p>&nbsp; &nbsp; &nbsp; &nbsp;是的，因为不断抽取而来的。</p>
<p>2、抽象类中是否可以不定义抽象方法。</p>
<p>　　是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用</p>
<p>3、抽象关键字abstract不可以和哪些关键字共存？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>
<p class="a">　　1、private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。</p>
<p class="a">　　2、final，暂时不关注，后面学</p>
<p class="a"><span style="color: #000000;">　　3、static，暂时不关注，后面学</span></p>
<p class="a">&nbsp;</p>
<p class="a">&nbsp;</p>
<p class="a">&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>