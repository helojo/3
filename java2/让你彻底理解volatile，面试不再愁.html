<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修让你彻底理解volatile，面试不再愁' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>让你彻底理解volatile，面试不再愁</center></div><div class='banquan'>原文出处:本文由博客园博主Java博客手留余香提供。<br/>
原文连接:https://www.cnblogs.com/yuxiang1/p/11842756.html</div><br>
    <blockquote>
<p><span style="font-size: 16px;"><span style="color: #ff9900;">本人免费整理了Java高级资料，涵盖了Java、Redis、MongoDB、MySQL、Zookeeper、Spring Cloud、Dubbo高并发分布式等教程，一共30G，需要自己领取。</span><br /><span style="color: #ff9900;">传送门</span>：<a class=" wrap external" href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttps%253A%252F%252Flink.zhihu.com%252F%253Ftarget%253Dhttps%25253A%252F%252Fmp.weixin.qq.com%252Fs%252FJzddfH-7yNudmkjT0IRL8Q" rel="nofollow noreferrer" target="_blank" data-za-detail-view-id="1043">https://mp.weixin.qq.com/s/JzddfH-7yNudmkjT0IRL8Q</a></span></p>
</blockquote>
<p>&nbsp;</p>
<p><strong><span style="font-size: 16px;">1. volatile简介</span></strong><br /><span style="font-size: 16px;">在上一篇文章中我们深入理解了java关键字</span></p>
<p><span style="font-size: 16px;">
<a class="LinkCard LinkCard--hasImage" href="https://zhuanlan.zhihu.com/p/91007628" target="_blank" data-draft-node="block" data-draft-type="link-card" data-image="https://pic4.zhimg.com/v2-86fea9c597c0ec398988ac3337ca42bb_180x120.jpg" data-image-width="1920" data-image-height="1200" data-za-detail-view-id="172"><span class="LinkCard-backdrop"><span class="LinkCard-content"><span class="LinkCard-text"><span class="LinkCard-title" data-text="true">这篇文章带你彻底理解</span></span></span></span></a></span></p>
<p><span style="font-size: 16px;">我们知道在java中还有一大神器就是关键volatile，可以说是和synchronized各领风骚，其中奥妙，我们来共同探讨下。</span></p>
<p><br /><span style="font-size: 16px;">通过上一篇的文章我们了解到synchronized是阻塞式同步，在线程竞争激烈的情况下会升级为重量级锁。而volatile就可以说是java虚拟机提供的最轻量级的同步机制。</span></p>
<p><span style="font-size: 16px;">但它同时不容易被正确理解，也至于在并发编程中很多程序员遇到线程安全的问题就会使用synchronized。</span></p>
<p><span style="font-size: 16px;">Java内存模型告诉我们，各个线程会将共享变量从主内存中拷贝到工作内存，然后执行引擎会基于工作内存中的数据进行操作处理。</span></p>
<p><span style="font-size: 16px;">线程在工作内存进行操作后何时会写到主内存中？这个时机对普通变量是没有规定的，而针对volatile修饰的变量给java虚拟机特殊的约定，线程对volatile变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的&ldquo;可见性&rdquo;。</span></p>
<p><br /><span style="font-size: 16px;">现在我们有了一个大概的印象就是：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</span></p>
<p><br /><strong><span style="font-size: 16px;">2. volatile实现原理</span></strong><br /><span style="font-size: 16px;">volatile是怎样实现了？比如一个很简单的Java代码：</span><br /><span style="font-size: 16px;">instance = new Instancce() //instance是volatile变量</span><br /><br /><span style="font-size: 16px;">在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出Lock前缀的指令（具体的大家可以使用一些工具去看一下，这里我就只把结果说出来）。我们想这个Lock指令肯定有神奇的地方，那么Lock前缀的指令在多核处理器下会发现什么事情了？</span></p>
<p><span style="font-size: 16px;">主要有这两个方面的影响：</span><br /><span style="font-size: 16px;">1.将当前处理器缓存行的数据写回系统内存；</span></p>
<p><span style="font-size: 16px;">2.这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效</span></p>
<p><span style="font-size: 16px;">为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存（L1，L2或其他）后再进行操作，但操作完不知道何时会写到内存。</span></p>
<p><span style="font-size: 16px;">如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。</span></p>
<p><span style="font-size: 16px;">但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：</span></p>
<ol>
<li><span style="font-size: 16px;">Lock前缀的指令会引起处理器缓存写回内存；</span></li>
<li><span style="font-size: 16px;">一个处理器的缓存回写到内存会导致其他处理器的缓存失效；</span></li>
<li><span style="font-size: 16px;">当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</span></li>

</ol>
<p><span style="font-size: 16px;">这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</span></p>
<p><br /><strong><span style="font-size: 16px;">3. volatile的happens-before关系</span></strong><br /><span style="font-size: 16px;">经过上面的分析，我们已经知道了volatile变量可以通过缓存一致性协议保证每个线程都能获得最新值，即满足数据的&ldquo;可见性&rdquo;。</span></p>
<p><span style="font-size: 16px;">我们继续延续上一篇分析问题的方式（我一直认为思考问题的方式是属于自己，也才是最重要的，也在不断培养这方面的能力），我一直将并发分析的切入点分为两个核心，三大性质。</span></p>
<p><span style="font-size: 16px;">两大核心：JMM内存模型（主内存和工作内存）以及happens-before；三条性质：原子性，可见性，有序性（关于三大性质的总结在以后得文章会和大家共同探讨）。</span></p>
<p><span style="font-size: 16px;">废话不多说，先来看两个核心之一：volatile的happens-before关系。</span></p>
<p><br /><span style="font-size: 16px;">在六条happens-before规则中有一条是：**volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。**下面我们结合具体的代码，我们利用这条规则推导下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> VolatileExample {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">int</span> a = 0<span style="color: #000000;">;
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">boolean</span> flag = <span style="color: #0000ff;">false</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> writer(){
        a </span>= 1;          <span style="color: #008000;">//</span><span style="color: #008000;">1</span>
        flag = <span style="color: #0000ff;">true</span>;   <span style="color: #008000;">//</span><span style="color: #008000;">2</span>
<span style="color: #000000;">    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> reader(){
        </span><span style="color: #0000ff;">if</span>(flag){      <span style="color: #008000;">//</span><span style="color: #008000;">3</span>
            <span style="color: #0000ff;">int</span> i = a; <span style="color: #008000;">//</span><span style="color: #008000;">4</span>
<span style="color: #000000;">        }
    }
}</span></code></pre>

<p>&nbsp;</p>

<p><br /><span style="font-size: 16px;">上面的实例代码对应的happens-before关系如下图所示：</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁0.png" alt="" width="587" data-caption="" data-size="normal" data-rawwidth="587" data-rawheight="524" data-original="https://pic1.zhimg.com/v2-b61c1fcfc3af09d4bea506da99992364_r.jpg" data-actualsrc="https://pic1.zhimg.com/v2-b61c1fcfc3af09d4bea506da99992364_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><span style="font-size: 16px;">加锁线程A先执行writer方法，然后线程B执行reader方法图中每一个箭头两个节点就代码一个happens-before关系，黑色的代表根据程序顺序规则推导出来，红色的是根据volatile变量的写happens-before 于任意后续对volatile变量的读，而蓝色的就是根据传递性规则推导出来的。</span></p>
<p><span style="font-size: 16px;">这里的2 happen-before 3，同样根据happens-before规则定义：如果A happens-before B,则A的执行结果对B可见，并且A的执行顺序先于B的执行顺序，我们可以知道操作2执行结果对操作3来说是可见的，也就是说当线程A将volatile变量 flag更改为true后线程B就能够迅速感知。</span></p>
<p><br /><strong><span style="font-size: 16px;">4. volatile的内存语义</span></strong><br /><span style="font-size: 16px;">还是按照两个核心的分析方式，分析完happens-before关系后我们现在就来进一步分析volatile的内存语义（按照这种方式去学习，会不会让大家对知识能够把握的更深，而不至于不知所措，如果大家认同我的这种方式，不妨给个赞，小弟在此谢过，对我是个鼓励）。</span></p>
<p><span style="font-size: 16px;">还是以上面的代码为例，假设线程A先执行writer方法，线程B随后执行reader方法，初始时线程的本地内存中flag和a都是初始状态，下图是线程A执行volatile写后的状态图。</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁1.png" alt="" width="601" data-caption="" data-size="normal" data-rawwidth="601" data-rawheight="426" data-original="https://pic3.zhimg.com/v2-7718b0046de2c36d8d873677d144f6de_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-7718b0046de2c36d8d873677d144f6de_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><span style="font-size: 16px;">当volatile变量写后，线程中本地内存中共享变量就会置为失效的状态，因此线程B再需要读取从主内存中去读取该变量的最新值。下图就展示了线程B读取同一个volatile变量的内存变化示意图。</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁2.png" alt="" width="542" data-caption="" data-size="normal" data-rawwidth="542" data-rawheight="418" data-original="https://pic2.zhimg.com/v2-daac292be093e735c665414fb6deb2f9_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-daac292be093e735c665414fb6deb2f9_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><span style="font-size: 16px;">从横向来看，线程A和线程B之间进行了一次通信，线程A在写volatile变量时，实际上就像是给B发送了一个消息告诉线程B你现在的值都是旧的了，然后线程B读这个volatile变量时就像是接收了线程A刚刚发送的消息。既然是旧的了，那线程B该怎么办了？自然而然就只能去主内存去取啦。</span></p>
<p><br /><span style="font-size: 16px;">好的，我们现在两个核心：happens-before以及内存语义现在已经都了解清楚了。是不是还不过瘾，突然发现原来自己会这么爱学习（微笑脸），那我们下面就再来一点干货----volatile内存语义的实现。</span></p>
<p><br /><strong><span style="font-size: 16px;">4.1 volatile的内存语义实现</span></strong><br /><span style="font-size: 16px;">我们都知道，为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序，那如果想阻止重排序要怎么办了？答案是可以添加内存屏障。</span></p>
<p><span style="font-size: 16px;">内存屏障</span><br /><span style="font-size: 16px;">JMM内存屏障分为四类见下图，</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁3.png" alt="" width="680" data-caption="" data-size="normal" data-rawwidth="680" data-rawheight="240" data-original="https://pic3.zhimg.com/v2-9c017db7acf891fcb5ae9b6ea9da3926_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-9c017db7acf891fcb5ae9b6ea9da3926_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><span style="font-size: 16px;">java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。</span></p>
<p><span style="font-size: 16px;">为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁4.png" alt="" width="680" data-caption="" data-size="normal" data-rawwidth="680" data-rawheight="135" data-original="https://pic4.zhimg.com/v2-c33488293bd156f70e8239964172514b_r.jpg" data-actualsrc="https://pic4.zhimg.com/v2-c33488293bd156f70e8239964172514b_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><span style="font-size: 16px;">"NO"表示禁止重排序。为了实现volatile内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。</span></p>
<p><span style="font-size: 16px;">对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM采取了保守策略：</span></p>
<ol>
<li><span style="font-size: 16px;">在每个volatile写操作的前面插入一个StoreStore屏障；</span></li>
<li><span style="font-size: 16px;">在每个volatile写操作的后面插入一个StoreLoad屏障；</span></li>
<li><span style="font-size: 16px;">在每个volatile读操作的后面插入一个LoadLoad屏障；</span></li>
<li><span style="font-size: 16px;">在每个volatile读操作的后面插入一个LoadStore屏障。</span></li>

</ol>
<p><span style="font-size: 16px;">需要注意的是：volatile写是在前面和后面分别插入内存屏障，而volatile读操作是在后面插入两个内存屏障</span><br /><span style="font-size: 16px;">StoreStore屏障：禁止上面的普通写和下面的volatile写重排序；</span><br /><span style="font-size: 16px;">StoreLoad屏障：防止上面的volatile写与下面可能有的volatile读/写重排序</span><br /><span style="font-size: 16px;">LoadLoad屏障：禁止下面所有的普通读操作和上面的volatile读重排序</span><br /><span style="font-size: 16px;">LoadStore屏障：禁止下面所有的普通写操作和上面的volatile读重排序</span><br /><span style="font-size: 16px;">下面以两个示意图进行理解，图片摘自相当好的一本书《java并发编程的艺术》。</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁5.png" alt="" width="620" data-caption="" data-size="normal" data-rawwidth="620" data-rawheight="383" data-original="https://pic2.zhimg.com/v2-52da5e63293ef5a4f7794c7331896531_r.jpg" data-actualsrc="https://pic2.zhimg.com/v2-52da5e63293ef5a4f7794c7331896531_b.jpg" data-lazy-status="ok" /></span></p>
<p class="ztext-empty-paragraph"><span style="font-size: 16px;">&nbsp;</span></p>
<p><span style="font-size: 16px;">
<img class="origin_image zh-lightbox-thumb lazy" src="./images/让你彻底理解volatile，面试不再愁6.png" alt="" width="620" data-caption="" data-size="normal" data-rawwidth="620" data-rawheight="355" data-original="https://pic3.zhimg.com/v2-b9916a63ba0e7039d8834b172f5edb8e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-b9916a63ba0e7039d8834b172f5edb8e_b.jpg" data-lazy-status="ok" /></span></p>
<p><br /><strong><span style="font-size: 16px;">5. 一个示例</span></strong><br /><span style="font-size: 16px;">我们现在已经理解volatile的精华了，文章开头的那个问题我想现在我们都能给出答案了。更正后的代码为：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> VolatileDemo {
    </span><span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">volatile</span> <span style="color: #0000ff;">boolean</span> isOver = <span style="color: #0000ff;">false</span><span style="color: #000000;">;

    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        Thread thread </span>= <span style="color: #0000ff;">new</span> Thread(<span style="color: #0000ff;">new</span><span style="color: #000000;"> Runnable() {
            @Override
            </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> run() {
                </span><span style="color: #0000ff;">while</span> (!<span style="color: #000000;">isOver) ;
            }
        });
        thread.start();
        </span><span style="color: #0000ff;">try</span><span style="color: #000000;"> {
            Thread.sleep(</span>500<span style="color: #000000;">);
        } </span><span style="color: #0000ff;">catch</span><span style="color: #000000;"> (InterruptedException e) {
            e.printStackTrace();
        }
        isOver </span>= <span style="color: #0000ff;">true</span><span style="color: #000000;">;
    }
}</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">注意不同点，现在已经将isOver设置成了volatile变量，这样在main线程中将isOver改为了true后，thread的工作内存该变量值就会失效，从而需要再次从主内存中读取该值，现在能够读出isOver最新值为true从而能够结束在thread里的死循环，从而能够顺利停止掉thread线程。</span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>