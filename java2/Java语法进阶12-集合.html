<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java语法进阶12-集合' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java语法进阶12-集合</center></div><div class='banquan'>原文出处:本文由博客园博主远离颠倒梦想提供。<br/>
原文连接:https://www.cnblogs.com/Open-ing/p/11991461.html</div><br>
    <h2 style="text-align: center;">集合</h2>
<p class="md-end-block md-focus"><span>集合：</span><span class="md-tab">是一种容器，用来装对象的容器，不能装基本数据类型。</span></p>
<p class="md-end-block"><span class="md-tab"> <span>数组也是容器，可以用来装基本数据类型，也可以用来装对象。</span></span></p>
<p class="md-end-block"><span class="md-tab"> 本质上，集合需要用对应的数据结构实现，是多个类实现接口<a title="颠倒梦想" href="https://www.cnblogs.com/Open-ing/p/11951499.html" target="_blank">Collection系列和Map</a>接口的统称</span></p>
<h3 class="md-end-block"><span class="md-tab"><span>Collection</span></span></h3>
<p>Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。</p>
<p><span class="md-expand">Collection<span class="md-tag md-raw-inline">&lt;E&gt;<span>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。</span></span></span></p>
<p><strong>Collection方法：</strong></p>
<table class="md-table">
<thead>
<tr class="md-end-block md-focus-container"><th><span class="td-span md-focus"><span class="md-expand">序号</span></span></th><th><span class="td-span"><span>归类</span></span></th><th><span class="td-span"><span>方法签名</span></span></th><th><span class="td-span"><span>方法描述</span></span></th></tr>
</thead>
<tbody>
<tr class="md-end-block">
<td><span class="td-span"><span>1</span></span></td>
<td><span class="td-span"><span>添加</span></span></td>
<td><span class="td-span"><span>add(E e)</span></span></td>
<td><span class="td-span"><span>添加一个元素对象到当前集合中</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>2</span></span></td>
<td><span class="td-span"><span>添加</span></span></td>
<td><span class="td-span"><span>addAll(Collection&lt;? extends E&gt; other)</span></span></td>
<td><span class="td-span"><span>添加多个元素，把other集合的所有元素都添加到当前集合中，this = this &cup; other；</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>3</span></span></td>
<td><span class="td-span"><span>删除</span></span></td>
<td><span class="td-span"><span>clear()</span></span></td>
<td><span class="td-span"><span>清空集合</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>4</span></span></td>
<td><span class="td-span"><span>删除</span></span></td>
<td><span class="td-span"><span>remove(Object obj)</span></span></td>
<td><span class="td-span"><span>删除一个元素，根据元素的equals()来判断是否是要被删除的元素，如果元素的类型没有重写equals方法，那么等价于==，如果重写了equals，那么就按照equals的规则来比较，一般比较内容。</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>5</span></span></td>
<td><span class="td-span"><span>删除</span></span></td>
<td><span class="td-span"><span>removeAll(Collection&lt;?&gt; coll)</span></span></td>
<td><span class="td-span"><span>删除多个元素，把当前集合中和c共同的元素删除，即this = this - this &cap; coll;子集</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>6</span></span></td>
<td><span class="td-span"><span>删除</span></span></td>
<td><span class="td-span"><span>retainAll(Collection&lt;?&gt;&nbsp; coll)</span></span></td>
<td><span class="td-span"><span>删除多个元素，在当前集合中保留和c的共同的元素，即this = this &cap; coll；交集</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>7</span></span></td>
<td><span class="td-span"><span>查</span></span></td>
<td><span class="td-span"><span>int size()</span></span></td>
<td><span class="td-span"><span>获取元素的个数</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>8</span></span></td>
<td><span class="td-span"><span>查</span></span></td>
<td><span class="td-span"><span>boolean contains(Object obj)</span></span></td>
<td><span class="td-span"><span>是否包含某个元素。根据元素的equals()来判断是否是要被删除的元素，如果元素的类型没有重写equals方法，那么等价于==，如果重写了equals，那么就按照equals的规则来比较，一般比较内容。</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>9</span></span></td>
<td><span class="td-span"><span>查</span></span></td>
<td><span class="td-span"><span>boolean containsAll(Collection&lt;?&gt; coll)</span></span></td>
<td><span class="td-span"><span>是否包含多个元素。判断当前集合中是否包含coll集合的所有元素，即coll是否是this的子集。</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>10</span></span></td>
<td><span class="td-span"><span>查</span></span></td>
<td><span class="td-span"><span>boolean isEmpty()</span></span></td>
<td><span class="td-span"><span>集合是否为空</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>11</span></span></td>
<td><span class="td-span"><span>遍历</span></span></td>
<td><span class="td-span"><span>Object[] toArray()</span></span></td>
<td><span class="td-span"><span>将集合中的元素用数组返回</span></span></td>
</tr>
<tr class="md-end-block">
<td><span class="td-span"><span>12</span></span></td>
<td><span class="td-span"><span>遍历</span></span></td>
<td><span class="td-span"><span>Iterator iterator()</span></span></td>
<td><span class="td-span"><span>返回一个迭代器对象，专门用于遍历集合</span></span></td>
</tr>
</tbody>
</table>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">Iterator迭代器</span></h3>
<p>即Collection集合元素的通用获取方式。每一种实现了Iterable接口的集合内部，都会有一个内部类实现了Iterator接口</p>
<ul>
<li class="md-list-item">
<p class="md-end-block md-focus"><span><code>public boolean <strong>hasNext()&nbsp;&nbsp;</strong></code><span>&nbsp;【如果仍有元素可以迭代，则返回 true。】</span></span></p>
</li>
<li><code>public E<strong> next()&nbsp;</strong></code>　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回迭代的下一个元素。】</li>
</ul>
<ul>
<li>void<strong>&nbsp;remove()</strong>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 　　【使用Iterator迭代器删除元素】</li>
</ul>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/Java语法进阶12-集合0.png" alt="" /></p>
<p>在调用Iterator的next方法之前，迭代器的索引位于第一个元素之前，指向第一个元素，当第一次调用迭代器的next方法时，返回第一个元素，然后迭代器的索引会向后移动一位，指向第二个元素，依此类推，直到hasNext方法返回false，表示到达了集合的末尾，终止对元素的遍历。</p>
<p>在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生java.util.NoSuchElementException没有集合元素的错误</p>
<p>注意：不要在使用Iterator迭代器进行迭代时，调用Collection的remove(xx)方法，否则会报异常java.util.ConcurrentModificationException，或出现不确定行为。</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">增强for</span></h3>
<p><span class="md-expand">增强for循环(也称for each循环)是<span><strong><span>JDK1.5</span></strong><span>以后出来的一个高级for循环，专门用来遍历数组和集合的，或者说实现了Iterable接口的其他容器名。</span></span></span></p>
<p>for(元素的数据类型&nbsp; 变量 : Collection集合or数组){ <br />  	　　//写操作代码<br />}</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">Iterable接口</span></h3>
<p>java.lang.Iterable接口，实现这个接口允许对象成为 "foreach" 语句的目标。</p>
<p class="md-end-block"><span>java.lang.Iterable接口的抽象方法：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span>public Iterator iterator():&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【获取对应的迭代器】</span></p>




</li>




</ul>
<p>foreach本质上就是使用Iterator迭代器进行遍历的。</p>
<p>所以也不要在foreach遍历的过程使用Collection的remove()方法。</p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">modCount</span></h3>
<p>如果在Iterator、ListIterator迭代器创建后的任意时间从结构上修改了集合（通过迭代器自身的 remove 或 add 方法之外的任何其他方式），则迭代器将抛出 ConcurrentModificationException。这就是Iterator迭代器的快速失败（fail-fast）机制。</p>
<p>结构性修改是指：改变list的size大小，或者，以其他方式改变他导致正在进行迭代时出现错误的结果。</p>
<p class="md-end-block"><span>那么如何实现快速失败（fail-fast）机制的呢？</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>在ArrayList等集合类中都有一个modCount变量。它用来记录集合的结构被修改的次数。</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>当我们给集合添加和删除操作时，会导致modCount++。</span></p>




</li>
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span>然后当我们用Iterator迭代器遍历集合时，创建集合迭代器的对象时，用一个变量记录当前集合的modCount。例如：<span><code>int expectedModCount = modCount;</code><span>，并且在迭代器每次next()迭代元素时，都要检查 <span><code>expectedModCount != modCount</code></span></span></span></span></p>




</li>




</ul>
<p>注意，迭代器的快速失败行为不能得到保证，<span class="md-expand">因此，编写依赖于此异常的程序的方式是错误的，正确做法是：<span class="md-expand">迭代器的快速失败行为应该仅用于检测 bug。</span></span></p>
<p>自定义类时如果一个实现类不希望提供fail-fast迭代器，则可以忽略这个字段。</p>
<h2 class="md-end-block md-heading md-focus" style="text-align: center;"><span class="md-expand">List</span></h2>
<p><span class="md-expand">List接口特点：</span></p>
<ol class="ol-list" start="">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span class="md-expand">它是一个元素存取有序的集合。即元素的存入顺序和取出顺序有保证。</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block md-focus"><span>集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。</span></p>




</li>




</ol>
<p><span class="md-expand">List集合关心元素是否<strong>有序</strong>，而不关心是否重复</span></p>
<p><span class="md-expand">List接口的实现类有很多，常见的有：</span></p>
<p class="md-end-block">ArrayList：动态数组　　Vector：动态数组　　LinkedList：双向链表　　Stack：栈</p>
<p><span class="md-expand">List除了从Collection集合继承的方法外，List 集合里添加了一些根据<strong>索引</strong>来操作集合元素的方法。</span></p>
<p class="md-end-block"><span>1、添加元素</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>void add(int index, E ele)　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【在[index]位置添加一个元素】　</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>boolean addAll(int index, Collection&lt;? extends E&gt; eles)&nbsp;　&nbsp; 【在[index]位置添加多个元素】</span></p>




</li>




</ul>
<p class="md-end-block"><span>2、获取元素</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span class="md-expand">E get(int index)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回[index]位置的元素】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>List subList(int fromIndex, int toIndex)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【截取[fromIndex,toIndex)部分的元素】</span></p>




</li>




</ul>
<p class="md-end-block"><span>3、获取元素索引</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>int indexOf(Object obj)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回obj在当前集合中第一次出现的下标】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>int lastIndexOf(Object obj)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回obj在当前集合中最后一次出现的下标】</span></p>




</li>




</ul>
<p class="md-end-block"><span>4、删除和替换元素</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>E remove(int index)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【删除[index]位置的元素，返回被删除的元素】</span></p>




</li>
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span>E set(int index, E ele)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【替换[index]位置的元素，返回被替换的元素】&nbsp;</span></p>




</li>




</ul>
<p class="md-end-block"><span>5、遍历</span></p>
<p class="md-end-block"><span class="md-expand">在原来Iterator和foreach遍历的基础上增加了：</span></p>
<p class="md-end-block"><span>ListIterator listIterator()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【默认游标在[0]开始】</span></p>
<p class="md-end-block md-focus"><span>ListIterator listIterator(int index)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【默认游标在[index]位置】</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">ListIterator</span></h3>
<p><span class="md-expand">List 集合额外提供了一个 listIterator() 方法，该方法返回一个 ListIterator 对象， ListIterator 接口继承了 Iterator 接口，提供了专门操作 List 的方法：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span class="md-expand">void add()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【通过迭代器添加元素到对应集合】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>void set(E e)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【用指定元素替换 <tt>next</tt> 或 <tt>previous</tt> 返回的最后一个元素】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>void remove()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【从列表中移除由 <tt>next</tt> 或 <tt>previous</tt> 返回的最后一个元素】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>boolean hasPrevious()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【如果以逆向遍历列表，往前是否还有元素。则返回&nbsp;<tt>true</tt>】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>E&nbsp; previous()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回列表中的前一个元素。】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>int previousIndex()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【返回列表中的前一个元素的索引】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>boolean hasNext()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【以正向遍历列表时，如果列表迭代器有多个元素，则返回 <tt>true</tt>】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block"><span>E&nbsp; next()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【返回列表中的下一个元素。】</span></p>




</li>
<li class="md-list-item">
<p class="md-end-block md-focus"><span>int nextIndex()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【返回对 <tt>next</tt> 的后续调用所返回元素的索引。】</span></p>




</li>




</ul>
<h2 class="md-end-block md-heading md-focus" style="text-align: center;"><span class="md-expand">Set</span></h2>
<p class="md-end-block"><span class="md-expand">set接口没有提供额外的方法。但是比<span><code>Collection</code><span>接口更加严格了。</span></span></span></p>
<p class="md-end-block"><span>Set 集合不允许包含相同的元素，如果试把两个相同的元素加入同一个 Set 集合中，则添加操作失败。</span></p>
<p class="md-end-block"><span>Set集合支持的遍历方式和Collection集合一样：foreach和Iterator。</span></p>
<p class="md-end-block md-focus"><span class="md-expand">Set集合的实现类：TreeSet：按大小顺序，LinkedHashSet：按照添加的顺序，HashSet：无序</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">HashSet</span></h3>
<p class="md-end-block md-focus"><span>HashSet 是 Set 接口的典型实现，大多数时候使用 Set 集合时都使用这个实现类。</span></p>
<p class="md-end-block"><span><code>java.util.HashSet</code><span>底层的实现其实是一个<span><code>java.util.HashMap</code><span>支持，然后HashMap的底层物理实现是一个Hash表。</span></span></span></span></p>
<p><span class="md-expand">HashSet 集合判断两个元素相等的标准：两个对象通过 hashCode() 方法比较相等，并且两个对象的 equals() 方法返回值也相等。因此，存储到HashSet的元素要重写hashCode和equals方法。</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">LinkedHashSet</span></h3>
<p><span class="md-expand"><span class="md-expand">LinkedHashSet是HashSet的子类，它在HashSet的基础上，在结点中增加两个属性before和after维护了结点的前后添加顺序。<span><code>java.util.LinkedHashSet</code><span>，它是链表和哈希表组合的一个数据存储结构。LinkedHashSet插入性能略低于 HashSet，但在迭代访问 Set 里的全部元素时有很好的性能。</span></span></span></span></p>
<p class="md-end-block"><span>HashSet/LinkedHashSet：</span><span class="md-tab"><span class="md-expand">如何区别元素的不可重复。依赖于元素的hashCode和equals方法</span></span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">TreeSet</span></h3>
<p class="md-end-block"><span>底层结构：里面维护了一个TreeMap，都是基于红黑树实现的！</span></p>
<p class="md-end-block"><span>特点：<span class="md-softbreak"> <span class="md-tab"> <span>1、不允许重复<span class="md-softbreak">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;<span class="md-tab"><span>2、实现排序，<span class="md-softbreak">&nbsp;<span class="md-tab"><span>自然排序或定制排序</span></span></span></span></span></span></span></span></span></span></p>
<p>如果使用的是自然排序（Comparable），则通过调用实现的compareTo方法</p>
<p><strong>自然排序</strong>：它判断两个对象是否相等的唯一标准是：两个对象通过 compareTo(T o) 方法比较返回值为0。</p>
<p>如果使用的是定制排序（Comparator），则通过调用比较器的compare方法</p>
<p><span class="md-expand"><strong>定制排序</strong>：使用定制排序判断两个元素相等的标准是：通过compare(T o1,T o2)比较两个元素返回了0。</span></p>
<p><span class="md-expand">如果希望保持一致性，在重写compareTo时，一般也会重写equals方法。不是语法要求，而且逻辑意义问题。</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">Collection系列的集合框架图</span></h3>
<p><span class="md-expand"><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/Java语法进阶12-集合1.png" alt="" /></span></p>
<h2 class="md-end-block md-heading md-focus" style="text-align: center;"><span class="md-expand">Map</span></h2>
<p><code>Collection</code>中的集合称为单列集合，<code>Map</code>中的集合称为双列集合。java.util.Map&lt;K,V&gt;</p>
<p class="md-end-block"><span>1、存储键值对(key,value)，也称为映射关系，键值对是Map.Entry接口的实现类对象。</span></p>
<p class="md-end-block"><span>2、所有存储到Map中的key不能重复，&nbsp;每个键只能对应一个值（这个值可以是单个值，也可以是个数组或集合值）。</span></p>
<p class="md-end-block md-focus"><span class="md-expand">3、所有存储到Map中的value可以重复</span></p>
<h3>Map接口的API</h3>
<p>1、添加</p>
<p>V put(K key, V value)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【将一对键值对添加到当前map中，同一个key如果put两次，第二次会覆盖上次的value】</p>
<p>void putAll(Map m)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【将另一个map中的所有键值对添加到当前map中】</p>
<p>2、删除</p>
<p>void clear()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【清空所有映射关系】</p>
<p>V remove(Object key)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【根据key删除一整对键值对(key,value)】</p>
<p>3、查询</p>
<p>int size()：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【返回键值对的数量】</p>
<p>boolean containsKey(Object key)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;【是否包含某个key】</p>
<p>boolean containsValue(Object value)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【是否包含某个value】</p>
<p>V get(Object key)：&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【根据key获取value值，如果此映射不包含该键的映射关系，则返回&nbsp;<code>null</code>。】</p>
<p>boolean isEmpty()　&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;　【如果此映射未包含键-值映射关系，则返回 <tt>true</tt>。】</p>
<p>4、遍历</p>
<p>Set&lt;Entry&lt;K,V&gt;&gt;&nbsp; entrySet()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【遍历所有的键值对，映射关系的 <a title="java.util 中的接口"><code>Set</code></a> 视图 】</p>
<p>Set&lt;K&gt;&nbsp; keySet()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【遍历所有的key，键的 <a title="java.util 中的接口"><code>Set</code></a> 视图】</p>
<p>Collection&lt;V&gt;&nbsp; values()&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 【遍历所有的value，值的 <a title="java.util 中的接口"><code>Collection</code></a> 视图】</p>
<p class="md-end-block md-focus"><span class="md-expand">使用put方法时，若指定的键(key)在集合中没有，则没有这个键对应的值，返回null，并把指定的键值添加到集合中； </span></p>
<p class="md-end-block md-focus"><span>若指定的键(key)在集合中存在，则返回值为集合中键对应的值（该值为替换前的值），并把指定键所对应的值，替换成指定的新值。</span></p>
<h3 class="md-end-block md-heading md-focus"><span class="md-expand">Map集合的遍历</span></h3>
<p>&nbsp;Map的遍历，不能支持foreach</p>
<p class="md-end-block"><span>（1）分开遍历：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>单独遍历所有key</span></p>



</li>
<li class="md-list-item">
<p class="md-end-block"><span>单独遍历所有value</span></p>



</li>



</ul>
<p class="md-end-block"><span>（2）成对遍历：</span></p>
<ul class="ul-list" data-mark="*">
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span class="md-expand">遍历的是映射关系Map.Entry类型的对象，Map.Entry是Map接口的内部接口。每一种Map内部有自己的Map.Entry的实现类。在Map中存储数据，实际上是将Key----&gt;value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象</span></p>


</li>


</ul>
<p><img style="display: block; margin-left: auto; margin-right: auto;" src="./images/Java语法进阶12-集合2.png" alt="" /></p>
<p>&nbsp;Map接口的常用实现类：HashMap、TreeMap、LinkedHashMap和Properties。其中HashMap是 Map 接口使用频率最高的实现类。</p>
<h4 class="md-end-block md-heading md-focus"><span class="md-expand">HashMap和Hashtable的区别与联系</span></h4>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span>HashMap和Hashtable都是哈希表。</span></p>



</li>



</ul>
<ul class="ul-list" data-mark="*">
<li class="md-list-item">
<p class="md-end-block"><span class="md-expand">HashMap和Hashtable判断两个 key 相等的标准是：两个 key 的hashCode 值相等，并且 equals() 方法也返回 true。因此，为了成功地在哈希表中存储和获取对象，用作键的对象必须实现 hashCode 方法和 equals 方法。</span></p>



</li>
<li class="md-list-item">
<p class="md-end-block"><span>Hashtable是线程安全的，任何非 null 对象都可以用作键或值。不允许null键</span></p>



</li>
<li class="md-list-item md-focus-container">
<p class="md-end-block md-focus"><span>HashMap是线程不安全的，并允许使用 null 值和 null 键。</span></p>



</li>



</ul>
<h4 class="md-end-block md-heading md-focus"><span>LinkedHashMap</span></h4>
<p class="md-end-block"><span class="md-expand">LinkedHashMap 是 HashMap 的子类。LinkedHashMap实现与 HashMap 的不同之处在于，LinkedHashMap维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，该迭代顺序通常就是将键插入到映射中的顺序（插入顺序）。</span></p>
<h4 class="md-end-block md-heading md-focus"><span>TreeMap</span></h4>
<p class="md-end-block"><span class="md-expand">基于红黑树（Red-Black tree）的 NavigableMap 实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</span></p>
<h4 class="md-end-block md-heading md-focus"><span>Properties</span></h4>
<p class="md-end-block"><span>Properties 类是 Hashtable 的子类，Properties 可保存在<strong>流</strong>中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</span></p>
<p class="md-end-block"><span>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法。</span></p>
<p>更多方法请见API文档</p>
<h4 class="md-end-block md-heading md-focus"><span>Set集合与Map集合的关系</span></h4>
<p class="md-end-block"><span class="md-expand">Set的内部实现其实是一个Map。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。</span></p>
<p>咱们存到Set中只有一个元素，又是怎么变成(key,value)的呢？</p>
<p>原来是，把添加到Set中的元素作为内部实现map的key，然后用一个常量对象PRESENT对象，作为value。</p>
<h3 class="md-end-block md-heading md-focus"><a title="颠倒梦想" href="https://www.cnblogs.com/Open-ing/p/11951499.html" target="_blank"><span class="md-expand">集合框架图</span></a></h3>
<h3 class="md-end-block md-heading md-focus"><a title="颠倒梦想" href="https://www.cnblogs.com/Open-ing/p/11991952.html" target="_blank"><span class="md-expand">Collections工具类</span></a></h3>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>