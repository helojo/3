<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修谁说搞Java的不能玩机器学习？' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>谁说搞Java的不能玩机器学习？</center></div><div class='banquan'>原文出处:本文由博客园博主锅外的大佬提供。<br/>
原文连接:https://www.cnblogs.com/liululee/p/11801781.html</div><br>
    <h2 id="简介">简介</h2>
<p>机器学习在全球范围内越来越受欢迎和使用。 它已经彻底改变了某些应用程序的构建方式，并且可能会继续成为我们日常生活中一个巨大的（并且正在增加的）部分。<br />
没有什么包装且机器学习并不简单。 它对许多人来说似乎非常复杂并常常令人生畏。<br />
像谷歌这样的公司将自己的机器学习概念与开发人员联系起来，在谷歌帮助下让他们逐渐迈出第一步，故TensorFlow的框架诞生了。</p>
<h2 id="tensorflow为何物">TensorFlow为何物？</h2>
<p>TensorFlow是由谷歌使用Python和C++开发的开源机器学习框架。<br />
它可以帮助开发人员轻松获取数据，准备和训练模型，预测未来状态，以及执行大规模机器学习。<br />
有了它，我们可以训练和运行深度神经网络的内容，诸如光学字符识别，图像识别/分类，自然语言处理等。</p>
<h2 id="张量与操作">张量与操作</h2>
<p>TensorFlow基于计算图，你可以将其想象为具有节点和边的经典图。<br />
每个节点被称为操作，它们将零个或多个张量输入并产生零个或多个张量输出。 操作可以非常简单，例如基本的添加，但它们也可以非常复杂。<br />
张量被描绘为图的边缘，并且是核心数据单元。 当我们将它们提供给操作时，我们在这些张量上执行不同的功能。 它们可以具有单个或多个维度，有时也称为它们的等级(标量：等级0，向量：等级1，矩阵：等级2)。<br />
这些数据受到操作的影响通过张量传递到计算图中，故而称为TensorFlow。<br />
张量可以以任意数量的维度存储数据，并且有三种主要类型的张量：占位符，变量和常量。</p>
<h2 id="安装tensorflow">安装TensorFlow</h2>
<p>使用Maven，安装TensorFlow就像包含依赖项一样简单：</p>
<pre><code><code>&lt;dependency&gt;
  &lt;groupId&gt;org.tensorflow&lt;/groupId&gt;
  &lt;artifactId&gt;tensorflow&lt;/artifactId&gt;
  &lt;version&gt;1.13.1&lt;/version&gt;
&lt;/dependency&gt;</code></code></pre>
<p>如果你的设备支持GPU功能，可以添加以下依赖：</p>
<pre><code><code>&lt;dependency&gt;
  &lt;groupId&gt;org.tensorflow&lt;/groupId&gt;
  &lt;artifactId&gt;libtensorflow&lt;/artifactId&gt;
  &lt;version&gt;1.13.1&lt;/version&gt;
&lt;/dependency&gt;

&lt;dependency&gt;
  &lt;groupId&gt;org.tensorflow&lt;/groupId&gt;
  &lt;artifactId&gt;libtensorflow_jni_gpu&lt;/artifactId&gt;
  &lt;version&gt;1.13.1&lt;/version&gt;
&lt;/dependency&gt;</code></code></pre>
<p>你可以使用TensorFlow对象来检查当前操作的TensorFlow的版本。</p>
<pre class="java"><code>System.out.println(TensorFlow.version());</code></code></pre>
<h2 id="tensorflow的javaapi">TensorFlow的JavaAPI</h2>
<p>Java API TensorFlow提供包含在org.tensorflow包中。 它目前是实验性的，因此不能保证其稳定性。<br />
需要注意的是TensorFlow唯一完全支持的语言是Python，Java API几乎没有什么功能。<br />
API向我们介绍了新的类，接口，枚举和异常。</p>
<h5 id="类">类</h5>
<p>通过API引入的新类是：</p>
<ul>
<li>Graph：表示TensorFlow计算的数据流图；</li>
<li>Operation：在Tensors上执行计算的Graph节点；</li>
<li>OperationBuilder：Operations的构建器类；</li>
<li>Output<T>：操作产生的张量的符号句柄；</li>
<li>SavedModelBundle：表示从存储加载的模型；</li>
<li>SavedModelBundle.Loader：提供加载SavedModel的选项；</li>
<li>Server：进程内TensorFlow服务器，用于分布式训练；</li>
<li>Session：图形执行的驱动程序；</li>
<li>Session.Run：输出执行会话时获得的张量和元数据；</li>
<li>Session.Runner：运行操作并评估张量；</li>
<li>Shape：由操作产生的可能部分已知的张量形状；</li>
<li>Tensor<T>：静态类型的多维数组，其元素是由T描述的类型；</li>
<li>TensorFlow：描述TensorFlow运行时的静态实用程序方法；</li>
<li>Tensors：用于创建张量对象的类型安全工厂方法；</li>
</ul>
<h5 id="枚举">枚举</h5>
<ul>
<li>DataType：将张量中的元素类型表示为枚举；</li>
</ul>
<h5 id="接口">接口</h5>
<ul>
<li>Operand<T>：由TensorFlow操作的操作数实现的接口；</li>
</ul>
<h5 id="异常">异常</h5>
<ul>
<li>TensorFlowException：执行TensorFlow图时抛出的未经检查的异常</li>
</ul>
<p>如果我们将所有这些与Python中的tf模块进行比较将发现存在明显的区别。 Java API没有几乎相同的功能，至少目前如此。</p>
<h2 id="图graphs">图(Graphs)</h2>
<p>如前所述，TensorFlow基于计算图 - 其中org.tensorflow.Graph是Java的实现。<br />
注意：它的实例是线程安全的，尽管我们需要在完成它之后显式释放Graph使用的资源。</p>
<p>让我们从一个空图开始：</p>
<pre class="java"><code>Graph graph = new Graph();</code></code></pre>
<p>该对象是空的，所以这个图表意义不大。 要对它做任何操作，我们首先需要使用Operations加载它。<br />
我们使用opBuilder()方法来加载它，它返回一个OperationBuilder对象，一旦我们调用.build()方法，它就会将操作添加到我们的图形中。</p>
<h4 id="常量">常量</h4>
<p>让我们在图表中添加一个常量：</p>
<pre class="java"><code>Operation x = graph.opBuilder(&quot;Const&quot;, &quot;x&quot;)
               .setAttr(&quot;dtype&quot;, DataType.FLOAT)
               .setAttr(&quot;value&quot;, Tensor.create(3.0f))
               .build(); </code></code></pre>
<h4 id="占位符">占位符</h4>
<p>占位符是变量的“类型”，声明时没有赋值，他们的值将在之后进行分配。 这允许我们使用没有任何实际数据的操作来构建图形：</p>
<pre class="java"><code>Operation y = graph.opBuilder(&quot;Placeholder&quot;, &quot;y&quot;)
        .setAttr(&quot;dtype&quot;, DataType.FLOAT)
        .build();</code></code></pre>
<h4 id="函数">函数</h4>
<p>最后为了解决这个问题，我们需要添加某些函数。 这些可以像乘法，除法或加法一样简单，也可以像矩阵乘法一样复杂。 和之前一样，我们使用.opBuilder()方法定义函数：</p>
<pre class="java"><code>Operation xy = graph.opBuilder(&quot;Mul&quot;, &quot;xy&quot;)
  .addInput(x.output(0))
  .addInput(y.output(0))
  .build();  </code></code></pre>
<p>注意：我们使用input(0)作为张量可以有多个输出。</p>
<h4 id="图形可视化">图形可视化</h4>
<p>遗憾的是，Java API还没有包含任何允许像Python中一样可视化图形的工具。</p>
<h2 id="会话sessions">会话(Sessions)</h2>
<p>如前所述，Session是Graph的驱动程序。 它封装了执行Operation和Graph计算张量(tensors)的环境。<br />
这意味着我们构建的图(graph)中的张量(tensors)实际上并没有任何值，因为我们没有在会话(session)中运行图形(graph)。<br />
我们首先将图表添加到会话(session)中：</p>
<pre class="java"><code>Session session = new Session(graph);</code></code></pre>
<p>我们的操作知识简单地将x于y相乘，为了运行我们的图(graph)并得到计算结果，我们需要使用fetch()获取到xy的操作并为其提供x和y的值：</p>
<pre class="java"><code>Tensor tensor = session.runner().fetch(&quot;xy&quot;).feed(&quot;x&quot;, Tensor.create(5.0f)).feed(&quot;y&quot;, Tensor.create(2.0f)).run().get(0);
System.out.println(tensor.floatValue());</code></code></pre>
<p>运行这段代码将产生的结果如下：</p>
<pre class="java"><code>10.0f</code></code></pre>
<h2 id="java当中加载python中saving模块">Java当中加载Python中Saving模块</h2>
<p>这可能听起来有点奇怪，但由于Python是唯一受到良好支持的语言，因此Java API仍然没有保存模型的功能。<br />
这意味着Java API仅用于服务用例，至少在TensorFlow完全支持之前。 目前至少我们可以使用SavedModelBundle类在Python中训练和保存模型，然后使用Java加载它们来为它们提供服务：</p>
<pre class="java"><code>SavedModelBundle model = SavedModelBundle.load(&quot;./model&quot;, &quot;serve&quot;); 
Tensor tensor = model.session().runner().fetch(&quot;xy&quot;).feed(&quot;x&quot;, Tensor.create(5.0f)).feed(&quot;y&quot;, Tensor.create(2.0f)).run().get(0);  

System.out.println(tensor.floatValue());</code></code></pre>
<h2 id="结论">结论</h2>
<p>TensorFlow是一个功能强大且广泛使用的框架。 它不断得到改进，并最近被引入新语言：包括Java和JavaScript。<br />
尽管Java API还没有像TensorFlow在Python中那么多的功能，但它仍然可以作为向Java开发人员介绍TensorFlow的一个很好的开始。</p>
<blockquote>
<p>原文链接：<a href="https://stackabuse.com/how-to-use-tensorflow-with-java/" class="uri">https://stackabuse.com/how-to-use-tensorflow-with-java/</a><br />
作 者：David Landup<br />
译 者：klein<br />
------</p>
</blockquote>
<p>9月福利，关注公众号<br />
​<br />
后台回复：004，领取8月翻译集锦!<br />
​<br />
往期福利回复：001，002, 003即可领取！</p>
<p><img src="./images/谁说搞Java的不能玩机器学习？0.png" alt="img" /></p>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>