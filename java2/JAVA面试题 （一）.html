<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修JAVA面试题 （一）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>JAVA面试题 （一）</center></div><div class='banquan'>原文出处:本文由博客园博主若千、提供。<br/>
原文连接:https://www.cnblogs.com/Ruoqian/p/ms102_1.html</div><br>
    <hr />
<h6 id="java作用域public-private-protected-不写-friendly的区别">java作用域public private protected 不写-friendly的区别？</h6>
<ul>
<li>public：可以被任何类引用。</li>
<li>protected：除了其他包不能使用，当前类，子孙类，同一包下的所有类都可<br />
以使用。</li>
<li>friendly：不写时，子孙类和其他包不能使用，当前类，同一包下都可以使用。</li>
<li>private：只有当前类中可以使用。</li>
</ul>
<hr />
<h6 id="和-的区别">&amp; 和 &amp;&amp; 的区别。</h6>
<ul>
<li>&amp;是位运算符，而&amp;&amp;的逻辑运算符。二者没有可比性。</li>
</ul>
<hr />
<h6 id="collection和collections的区别">collection和collections的区别。</h6>
<ul>
<li>collection是java中容器框架的顶层接口。继承它的主要有list和set两个接口。</li>
<li>collections是针对容器类的一个帮助类。提供一系列的静态方法实现对容器的各种<br />
搜索，排序，线程安全化的操作。</li>
<li>线程安全化：使用synchronized方法将集合变为线程同步的安全集合。</li>
</ul>
<pre><code><code>class model{
    List list1 = Collections.synchronizedList(new ArrayList());
    List list2 = Collections.synchronizedMap(new Map&lt;String,String&gt;());
    List list3 = Collections.synchronizedSet(new TreeSet&lt;&gt;());
}</code></code></pre>
<hr />
<h6 id="string-snew-stringasd创建了多少个对象">String s=new String(&quot;asd&quot;)创建了多少个对象。</h6>
<ul>
<li>创建了两个。首先创建asd的字符串对象。然后new字符串对象将asd赋予它。</li>
<li>String s = &quot;asd&quot;：这种方式变量存储在方法区中。</li>
<li>new String(&quot;asd&quot;)： 这种方式对象存储在堆中。</li>
</ul>
<hr />
<h6 id="java中有没有goto关键字">java中有没有goto关键字？</h6>
<ul>
<li>java中的保留字，现在没有在java中使用。goto语句常与条件语句配合使用。可用来实现<br />
条件转移，构成循环，跳出循环体等功能。但是在结构化程序中，一般不使用goto语句，以免<br />
造成程序流的混乱，使理解和调试程序困难。</li>
</ul>
<hr />
<h6 id="的结果是多少">5%3、-5%3、5%-3、-5%-3的结果是多少？</h6>
<ul>
<li>以右边的符号为准：2 -2 2 -2</li>
</ul>
<hr />
<h6 id="overload和override的区别">Overload和Override的区别</h6>
<ul>
<li>重载：Overload在同一类中使用，只要方法名一致，参数个数，返回值都可以不用一致。访问类型也可以改。</li>
<li>重写：Override继承关系类使用，方法名，返回值，参数个数必须一致。访问类型必须必父类大。</li>
</ul>
<hr />
<h6 id="set容器里的元素是不能重复的那么使用什么方法实现的">set容器里的元素是不能重复的，那么使用什么方法实现的？</h6>
<ul>
<li>首先set集合的底层是map实现的，而map的key是不能重复的。map的key值不重复是因为put方法会先进行<br />
hashcode的比较，如果值一致那么再进行equals方法比较。这样保证key值得唯一性。</li>
</ul>
<hr />
<h6 id="error和exception的区别">error和exception的区别</h6>
<ul>
<li>error一般是指可以恢复但是非常困难的问题，如栈溢出，内存溢出。</li>
<li>exception指运行时异常，这是一种设计或者实现上的问题。</li>
</ul>
<hr />
<h6 id="jdk8的新特性-主要的">jdk8的新特性 主要的</h6>
<ul>
<li>Lambda表达式和函数式接口：</li>
</ul>
<pre><code><code>lambda表达式也称为闭包。是jdk8中的最大的改变，它允许我们将函数当成参数传递给某个方法，或者把代码
本身当做数据处理：函数式开发。</code></code></pre>
<ul>
<li>接口增加的默认方法和静态方法：</li>
</ul>
<pre><code><code>default和static</code></code></pre>
<ul>
<li>方法引用：</li>
</ul>
<pre><code><code>方法引用使得开发者可以引用现存的方法，java类的构造方法或者实例对象。一般和lambda表达式配合使用。
使得代码简介，紧凑。
构造器引用 Class::new///Class&lt;T&gt;::new
静态方法引用 Class::static_method
某个类的成员方法引用 Class::method 
实例对象的成员方法引用 instance::method</code></code></pre>
<ul>
<li>重复注解：</li>
</ul>
<pre><code><code>自从java5引进注解之后，注解使用的越来越多，尤其是在框架中，但是注解不能在一个地方多次使用，
java8打破了这个限制，可以在一个地方重复使用同一个注解，使用 @Repeatable定义重复的注解</code></code></pre>
<ul>
<li>更好的类型推断</li>
</ul>
<pre><code><code>编译器可以推导出某个参数的数据类型，使得代码更加的简洁</code></code></pre>
<ul>
<li>拓宽注解的应用场景</li>
</ul>
<pre><code><code>现在注解几乎可以使用在任何元素上。局部变量，接口，超类，实现类等</code></code></pre>
<hr />
<h6 id="抽象类的接口的区别">抽象类的接口的区别</h6>
<ul>
<li>相同点：都是不能被直接实例化的</li>
<li>不同点：</li>
</ul>
<pre><code><code>1. 抽象类是可以有方法体的，接口中没有，但是java8的新特性中接口可以写static和default关键字
的方法。
2. 抽象类中的成员变量可以随意修饰，接口中只能是public sttaic final类型 
3. 接口中不能含有静态代码块,静态方法。抽象类可以有，新特性之后，接口可以写静态方法。
4. 一个类只能单继承，但是可以多实现。
5. 抽象类可以定义成员变量，接口中的变量都是常量。</code></code></pre>
<hr />
<h6 id="抽象类是否可以继承实体类">抽象类是否可以继承实体类？</h6>
<ul>
<li>抽象类是可以继承实体类的，但是前提是实体类具有明确的构造函数。</li>
</ul>
<hr />
<h6 id="constructor可以被override么">constructor可以被override么？</h6>
<ul>
<li>不能，因为constructor是不能被继承的。但是可以被overload。</li>
</ul>
<hr />
<h6 id="string类可以被继承么">String类可以被继承么？</h6>
<ul>
<li>不能，该类是被final修饰的</li>
</ul>
<hr />
<h6 id="在try-catch-final中return在try语句里那么执行顺序">在try-catch-final中，return在try语句里，那么执行顺序？</h6>
<ul>
<li>final中的code会在return之前执行。</li>
</ul>
<hr />
<h6 id="静态变量和实例变量的区别">静态变量和实例变量的区别</h6>
<ul>
<li>静态变量是被static修饰的变量，也叫作类变量，不属于类的任何一个对象，一个类不管创建多少个对象<br />
静态变量在内存中有且仅有一个拷贝。</li>
<li>实例变量必须依托于某一个实例，需要先创建对象后通过对象才能访问，静态变量可以实现让多个对象共享<br />
内存</li>
</ul>
<hr />
<h6 id="arraylist和vector的区别hashmap和hashtable的区别">ArrayList和Vector的区别，HashMap和Hashtable的区别。</h6>
<blockquote>
<p>ArrayList和Vector：</p>
</blockquote>
<ul>
<li>同步性：ArrayList是线程不安全的，也即是不同步的，Vector是线程安全的，也即是同步的。</li>
<li><p>数据增长：ArrayList在达到阈值的时候会增长原来集合的50%，Vector则会增长100%。</p>
<blockquote>
<p>HashMap和Hashtable：</p>
</blockquote></li>
<li>历史原因：Hashtable是基于Dictionary类的，HashMap是java1.2引进的Map接口的一个实现。</li>
<li>同步性：Hashtable是线程安全的，HaspMap是线程不安全的的。</li>
<li><p>值：只有HashMap可以有空值，key或value。</p></li>
</ul>
<hr />
<h6 id="char变量可以存储一个汉字么为什么">char变量可以存储一个汉字么？为什么？</h6>
<ul>
<li><p>可以，java中以unicode编码，一个char占16字符，所以放中文是没有问题的。<br />
***</p>
<h6 id="gc是什么为什么要有gc">GC是什么？为什么要有GC？</h6></li>
<li><p>GC就是垃圾收集器。java不像C定义一个变量需要手动释放内存。主要就是GC实现的，他可以自动检测对象<br />
是否超过作用域从而达到自动回收的目的。</p></li>
</ul>
<hr />
<h6 id="string和stringbuffer和stringbuilder的区别">String和StringBuffer和StringBuilder的区别</h6>
<ul>
<li>String是长度不可变的，而Buffer和Builder是可变的。</li>
<li>buffer和builder最大的区别就是buffer是线程安全的，builder是线程不安全的。所以多线程推荐使用<br />
buffer，单线程使用builder。</li>
</ul>
<hr />
<h6 id="finalfinallyfinalize的区别">final，finally，finalize的区别</h6>
<ul>
<li>final：修饰符，修饰类：不可被继承，修饰变量：变为常量，修饰方法：不能重载</li>
<li>finally：在处理异常时finally块来执行任何清除操作。</li>
<li>finalize：方法名，java允许finalize方法在GC将对象从内存中清除之前做必要的清理工作。此方法是<br />
GC确定该对象没有被使用的时候调用的，属于Object类，所以所有类都有该方法。</li>
</ul>
<hr />
<h6 id="面向对象的特性">面向对象的特性</h6>
<ul>
<li>抽象</li>
<li>继承</li>
<li>封装</li>
<li>多态</li>
</ul>
<hr />
<h6 id="基本数据类型">基本数据类型</h6>
<ul>
<li>byte char int short long double float boolean</li>
</ul>
<hr />
<h6 id="int和integer的区别">int和integer的区别</h6>
<ul>
<li>int是基本数据类型，integer是int的封装类型。</li>
</ul>
<hr />
<h6 id="arraylist和vector和linkedlist的存储性能和特性">ArrayList和Vector和LinkedList的存储性能和特性</h6>
<ul>
<li>ArrayList和Vector都是基于数组实现的，所以查询快，但是ArrayList是线程不安全的，Vector是线程<br />
安全的，其次，Vector的性能较差。</li>
<li>LinkedList是基于链表的，所以插入，删除，更改快。</li>
</ul>
<hr />
<h6 id="heap和stack的区别">heap和stack的区别</h6>
<blockquote>
<p>heap堆，stack栈。</p>
</blockquote>
<ul>
<li>栈：存取快，仅次于CPU中的寄存器，栈中的数据大小和生存区是确定的，缺乏灵活性。栈数据可以共享</li>
<li>堆：动态分配内存大小：堆中的GC可以周期的收取不再使用的对象。因为动态分配内存，存取慢。</li>
</ul>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>