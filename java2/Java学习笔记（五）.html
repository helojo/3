<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Java学习笔记（五）' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Java学习笔记（五）</center></div><div class='banquan'>原文出处:本文由博客园博主小喵钓鱼提供。<br/>
原文连接:https://www.cnblogs.com/xmdykf/p/11444277.html</div><br>
    <p>&nbsp;</p>
<blockquote>
<h2>&nbsp;<strong>　　类和对象</strong></h2>
</blockquote>
<p>&nbsp;</p>
<h3>&nbsp;<strong>一，引用</strong></h3>
<p>&nbsp;　<strong>　即 创建类的实例 ==&gt; 对象</strong></p>
<p>　　new Hero(); 代表创建了一个 Hero 对象，但是却无法访问它，所以需要引用它</p>
<src class="cnblogs_code">
<pre><code>Hero hero = <span style="color: #0000ff;">new</span> Hero();</code></pre>

<p>&nbsp;</p>
<p>&nbsp;　　h 是的变量类型是 Hero 类，又称 引用，在 C++ 中 经常以 &amp;h = Hero(); 来做引用</p>
<p>　　当然，可以多个引用指向一个对象，就好像贴标签似的，一个引用指向多个对象，但是往往后者会替代前者，毕竟将标签撕下，并贴在了另一个上面</p>
<p>&nbsp;</p>
<h3>二、继承</h3>
<h4>&nbsp;　　语法 =&gt;&nbsp;</h4>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> student <span style="color: #0000ff;">extends</span> People{}</code></pre>

<p>　　然后，student 就 具有了 People类中的部分属性和方法（具体引用部分见 访问修饰符）</p>
<p>&nbsp;</p>
<h3>三、方法重载</h3>
<h4>　　重载的条件 =&gt;</h4>
<p>　　&nbsp; &nbsp;1. 方法名一样，<strong>参数个数</strong>一样，<strong>部分参数类型</strong>不一样, <strong>返回类型</strong>一样</p>
<p>　　　2. 方法名一样，<strong>参数个数</strong>不一样, <strong>返回类型</strong>一样</p>
<p>　　　3. 方法名一样，&nbsp;<strong>参数</strong>一样,&nbsp;<strong>返回类型</strong>不一样,</p>
<p>&nbsp;</p>
<h3>四、构造方法</h3>
<p>　　顾名思义，就是通过类创建对象时，调用的方法，实例化一个对象时，必然调用构造方法</p>
<p>　　语法 =&gt;&nbsp;</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> Hero(){}</code></pre>

<blockquote>
<p>　　补充 =&gt;&nbsp; 构造方法也是可以<strong>有参</strong>的，即 构造方法可以&nbsp;<strong>重载</strong></p>
</blockquote>
<p>&nbsp;</p>
<h3>五、this 关键字</h3>
<p>　this 代表当前对象，也就是可以通过 this 关键字访问 对象的属性</p>
<p>　当然，要在一个构造方法中，调用另一个构造方法，可以使用 this()　</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('a2296a27-be08-4139-8ce2-726912dc14f4')"><img id="code_img_closed_a2296a27-be08-4139-8ce2-726912dc14f4" class="code_img_closed" src="./images/Java学习笔记（五）0.png" alt="" /><img id="code_img_opened_a2296a27-be08-4139-8ce2-726912dc14f4" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('a2296a27-be08-4139-8ce2-726912dc14f4',event)" src="./images/Java学习笔记（五）1.png" alt="" />
<src id="cnblogs_code_open_a2296a27-be08-4139-8ce2-726912dc14f4" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> packet;

</span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> Four_this {
    String name;
    </span><span style="color: #0000ff;">float</span><span style="color: #000000;"> hp;
    </span><span style="color: #0000ff;">float</span><span style="color: #000000;"> armor;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> moveSpeed;
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">void</span> addSpeed(<span style="color: #0000ff;">int</span><span style="color: #000000;"> speed)
    {
        </span><span style="color: #0000ff;">this</span>.moveSpeed +=<span style="color: #000000;"> speed;
    }
    </span><span style="color: #0000ff;">public</span>  Four_this(String name, <span style="color: #0000ff;">float</span><span style="color: #000000;"> hp)
    {
        </span><span style="color: #0000ff;">this</span>.name =<span style="color: #000000;"> name;
        </span><span style="color: #0000ff;">this</span>.hp =<span style="color: #000000;"> hp;
    }
    </span><span style="color: #0000ff;">public</span> Four_this(String name, <span style="color: #0000ff;">float</span> hp, <span style="color: #0000ff;">float</span> armor, <span style="color: #0000ff;">int</span><span style="color: #000000;"> moveSpeed)
    {
        </span><span style="color: #0000ff;">this</span>(name, hp);  <span style="color: #008000;">//</span><span style="color: #008000;"> 通过this 调用其他的构造方法</span>
        <span style="color: #0000ff;">this</span>.armor = armor;  <span style="color: #008000;">//</span><span style="color: #008000;"> 通过 this 调用属性</span>
        <span style="color: #0000ff;">this</span>.moveSpeed =<span style="color: #000000;"> moveSpeed;
        </span><span style="color: #0000ff;">this</span>.addSpeed(10<span style="color: #000000;">);
    }
    </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {

        Four_this four </span>= <span style="color: #0000ff;">new</span> Four_this("Tom", 200, 300,100<span style="color: #000000;">);
    }

}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>&nbsp;</p>
<p>&nbsp;　</p>
<h3>&nbsp;六、传参</h3>
<p>　基本类型传参，在方法内，无法修改方法外的基本类型参数</p>
<p>　类类型（又称引用）传参，两个引用都指向了一个对象，所以可以修改 =-=&nbsp;</p>
<p>　但是 如果 将 形参的引用 重新 指向一个新的对象，则无法修改</p>
<p>&nbsp;</p>
<h3>七、包</h3>
<p>　　<strong>使用 同包 下的 类，则直接使用即可，前提是 开头都 有</strong></p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">import</span> 所在包名;</code></pre>

<p>　　使用 不同包 下的类，则需要 import 别的包名.需要引用的类名</p>
<p>　　　这样才能进行 使用</p>
<p>&nbsp;</p>
<h3>八、访问修饰符</h3>
<h4>　　成员函数有 四种访问修饰符</h4>
<p><span class="strong">　　　private&nbsp;私有的<br /><span class="tab"><span class="strong">　　　package/friendly/default 不写, 默认<br /><span class="tab"><span class="strong">　　　protected&nbsp;受保护的<br /><span class="tab"><span class="strong">　　　public&nbsp;公共的</span></span></span></span></span></span></span></p>
<p>&nbsp;</p>
<h4>&nbsp;　　关于与之相关的类与类之间的关系</h4>
<p><img src="./images/Java学习笔记（五）2.png" alt="" /></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<blockquote>
<p><strong>&nbsp;问题：那什么情况该用什么修饰符？</strong></p>
<p>　　1. 属性通常使用private封装起来<br />　　2. 方法一般使用public用于被调用<br />　　3. 会被子类继承的方法，通常使用protected<br />　　4. package用的不多，一般新手会用package,因为还不知道有修饰符这个东西<br /><br />　　再就是<span class="strong">作用范围最小原则<br />　　简单说，能用private就用private，不行就放大一级，用package,再不行就用protected，最后用public。 这样就能把数据尽量的封装起来，没有必要<span class="strong">露出来的，就不用<span class="strong">露出来了</span></span></span></p>


</blockquote>
<p>&nbsp;</p>
<h3>九、类属性</h3>
<h4>　当一个属性被 static 修饰的时候，就叫类属性，又叫静态属性（和 C++ 中基本一模一样）</h4>
<blockquote>
<p><strong>　补充 =&gt;&nbsp; 调用类属性时，最好使用 类名. 类属性名</strong></p>


</blockquote>
<p>&nbsp;</p>
<h3>十、类方法</h3>
<p>　　<strong>类方法</strong>又叫&nbsp;<strong>静态方法</strong>，一般创建类方法的条件是，这个方法为<strong>功能性函数</strong>，不涉及对象的属性，当然在静态方法中也调用不了对象的方法就是了（<strong>例如 random() 就是 Math 的一个功能用途的函数</strong>）</p>
<p>　　<strong>对象方法</strong>又叫<strong>实例方法</strong>，<strong>非静态方法</strong></p>
<p>　　<strong>区别：</strong></p>
<p>　　　访问一个对象方法，必须建立在有一个对象的基础上</p>
<p>　　　访问一个类方法，不需要对象的存在，直接访问即可</p>
<p>&nbsp;</p>
<h3>&nbsp;十一、属性初始化</h3>
<h4>　　对象属性初始化有三种</h4>
<p>　　　1. 声明该属性的时候初始化</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> String name = "hello";  <span style="color: #008000;">//</span><span style="color: #008000;"> 声明该属性的时候初始化</span></code></pre>

<p>　　　2. 构造函数中初始化</p>
<p>　　　3. 初始化块</p>
<src class="cnblogs_code">
<pre><code><span style="color: #000000;">public String name;<br />{
       name </span>= "hello" ;  <span style="color: #008000;">//</span><span style="color: #008000;"> 初始化块</span>
}</code></pre>

<p>&nbsp;</p>
<blockquote>
<p>&nbsp;　<strong>　三种方式的执行顺序是，1 =&gt; 3 =&gt; 2</strong></p>
</blockquote>
<h4>&nbsp;<strong>　</strong>　类属性初始化方式有两种</h4>
<p>　　　1. 声明该属性的时候初始化</p>
<p>　　　2. 静态初始化块</p>
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">int</span> item=8;  <span style="color: #008000;">//</span><span style="color: #008000;"> 声明的时候初始化</span>

<span style="color: #0000ff;">static</span><span style="color: #000000;">{
      item </span>= 6;  <span style="color: #008000;">//</span><span style="color: #008000;"> 静态初始化块 初始化  </span>
}</code></pre>

<p>&nbsp;</p>
<p>&nbsp;</p>
<h3>十二、单例模式</h3>
<p>　　单例 简单点说就是，一个类 只能创建一个实例，即一个对象，不论创建多少个，他们都是一样的，也就是只有一个</p>
<h4>　　单例三元素</h4>
<p>　　　1. 构造方法私有化</p>
<p>　　　2. 静态属性指向实例</p>
<p>　　　3. public static getInstance方法，返回第二步的静态属性</p>
<h4>　<strong>　</strong>有 两种 单例模式</h4>
<h5>　　1. 饿汉式单例模式</h5>
<p>　　　首先 通过 私有化 其构造方法，使得外部无法通过 new 得到 新的实例，然后 通过 public static getInstance() 方法，外部调用通过该方法获取 对象，且每次都是获取同一个对象</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('97f83dd0-ec05-4b18-87c1-d7f3f3cbaba8')"><img id="code_img_closed_97f83dd0-ec05-4b18-87c1-d7f3f3cbaba8" class="code_img_closed" src="./images/Java学习笔记（五）0.png" alt="" /><img id="code_img_opened_97f83dd0-ec05-4b18-87c1-d7f3f3cbaba8" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('97f83dd0-ec05-4b18-87c1-d7f3f3cbaba8',event)" src="./images/Java学习笔记（五）1.png" alt="" />
<src id="cnblogs_code_open_97f83dd0-ec05-4b18-87c1-d7f3f3cbaba8" class="cnblogs_code_hide">
<pre><code><span style="color: #0000ff;">package</span><span style="color: #000000;"> packet;
</span><span style="color: #008000;">//</span><span style="color: #008000;"> 饿汉式单例模式</span>
<span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> single {
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 单例 只能被实例化一次
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过私有化其构造方法，使得外部无法通过new 得到新的实例</span>
    <span style="color: #0000ff;">private</span><span style="color: #000000;"> single(){

    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 准备一个类属性，指向一个实例化对象，因为是类属性，只有一个</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">static</span>  single instance = <span style="color: #0000ff;">new</span><span style="color: #000000;"> single();
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> public static 方法，提供给调用者 获取 12行定义的对象</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> single getInstance()
    {
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> instance;
    }
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 提供了一个public static的getInstance方法
    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 这种单例模式又叫做饿汉式单例模式，无论如何都会创建一个实例</span>
    <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">void</span><span style="color: #000000;"> main(String[] args) {
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 通过new 实例化会报错
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 只能通过 getInstance 得到对象</span>
        single g1 =<span style="color: #000000;"> single.getInstance();
        single g2 </span>=<span style="color: #000000;"> single.getInstance();
        System.out.println(g1 </span>==<span style="color: #000000;"> g2);
    }
}</span></code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>&nbsp;</p>
<h5>&nbsp;　　2. 懒汉式单例模式</h5>
<p>　　　懒汉式单例模式与饿汉式单例模式不同，只有在调用 getInstance 的时候，才会创建实例</p>
<src class="cnblogs_code" onclick="cnblogs_code_show('6d706585-5ecb-4721-aa17-84a8588fc249')"><img id="code_img_closed_6d706585-5ecb-4721-aa17-84a8588fc249" class="code_img_closed" src="./images/Java学习笔记（五）0.png" alt="" /><img id="code_img_opened_6d706585-5ecb-4721-aa17-84a8588fc249" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('6d706585-5ecb-4721-aa17-84a8588fc249',event)" src="./images/Java学习笔记（五）1.png" alt="" />
<src id="cnblogs_code_open_6d706585-5ecb-4721-aa17-84a8588fc249" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;"> 1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> packet;
</span><span style="color: #008080;"> 2</span> <span style="color: #008000;">//</span><span style="color: #008000;"> 懒汉式单例模式</span>
<span style="color: #008080;"> 3</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span><span style="color: #000000;"> single2 {
</span><span style="color: #008080;"> 4</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 单例 只能被实例化一次
</span><span style="color: #008080;"> 5</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 通过私有化其构造方法，使得外部无法通过new 得到新的实例</span>
<span style="color: #008080;"> 6</span>     <span style="color: #0000ff;">private</span><span style="color: #000000;"> single2(){
</span><span style="color: #008080;"> 7</span> 
<span style="color: #008080;"> 8</span> <span style="color: #000000;">    }
</span><span style="color: #008080;"> 9</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> 准备一个类属性，用于执行一个实例化的对象，但是暂时指向null，区别于饿汉式</span>
<span style="color: #008080;">10</span>     <span style="color: #0000ff;">private</span>  <span style="color: #0000ff;">static</span><span style="color: #000000;">  single2 instance;
</span><span style="color: #008080;">11</span>     <span style="color: #008000;">//</span><span style="color: #008000;"> public static 方法 返回实例对象</span>
<span style="color: #008080;">12</span>     <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">static</span><span style="color: #000000;"> single2 getInstance(){
</span><span style="color: #008080;">13</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 第一次访问的时候，发现instance 没有指向对象，这时实例化一个对象</span>
<span style="color: #008080;">14</span>         <span style="color: #0000ff;">if</span> (<span style="color: #0000ff;">null</span> ==<span style="color: #000000;"> instance){
</span><span style="color: #008080;">15</span>             instance = <span style="color: #0000ff;">new</span><span style="color: #000000;"> single2();
</span><span style="color: #008080;">16</span> <span style="color: #000000;">        }
</span><span style="color: #008080;">17</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 返回instance 指向的对象</span>
<span style="color: #008080;">18</span>         <span style="color: #0000ff;">return</span><span style="color: #000000;"> instance;
</span><span style="color: #008080;">19</span> <span style="color: #000000;">    }
</span><span style="color: #008080;">20</span> }</code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<p>&nbsp;</p>
<blockquote>
<p>&nbsp;补充: 什么时候使用 饿汉式，什么时候使用懒汉式？</p>
<p><span class="strong">饿汉式是立即加载的方式，无论是否会用到这个对象，都会加载。<br /><span class="tab">如果在构造方法里写了性能消耗较大，占时较久的代码，比如建立与数据库的连接，那么就会在启动的时候感觉稍微有些卡顿。<br /><br /><span class="strong">懒汉式，是延迟加载的方式，只有使用的时候才会加载。 并且有线程安全的考量<br /><span class="tab">使用懒汉式，在启动的时候，会感觉到比饿汉式略快，因为并没有做对象的实例化。 但是在第一次调用的时候，会进行实例化操作，感觉上就略慢。<br /><br />看业务需求，如果业务上允许有比较充分的启动和初始化时间，就使用饿汉式，否则就使用懒汉式</span></span></span></span></p>


</blockquote>
<p>&nbsp;　　</p>
<h3>十三， 枚举类型</h3>
<h4>　<strong>　</strong>假定一个枚举类先</h4>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> <span style="color: #0000ff;">package</span><span style="color: #000000;"> c;
</span><span style="color: #008080;">2</span> 
<span style="color: #008080;">3</span> <span style="color: #0000ff;">public</span> <span style="color: #0000ff;">enum</span><span style="color: #000000;">  Season {
</span><span style="color: #008080;">4</span> <span style="color: #000000;">    SPRING, SUMMER, AUTUMN, WINTER<br /></span>5 }</code></pre>

<p>&nbsp;</p>
<p>&nbsp;　<strong>　枚举 enum 是一个特殊的类，使用枚举 可以很方便的定义常量，如果要循环的得到枚举中的常量，可以使用增强型 for 循环</strong></p>
<src class="cnblogs_code" onclick="cnblogs_code_show('2c4533ac-d229-4355-9ebd-237457936e22')"><img id="code_img_closed_2c4533ac-d229-4355-9ebd-237457936e22" class="code_img_closed" src="./images/Java学习笔记（五）0.png" alt="" /><img id="code_img_opened_2c4533ac-d229-4355-9ebd-237457936e22" class="code_img_opened" style="display: none;" onclick="cnblogs_code_hide('2c4533ac-d229-4355-9ebd-237457936e22',event)" src="./images/Java学习笔记（五）1.png" alt="" />
<src id="cnblogs_code_open_2c4533ac-d229-4355-9ebd-237457936e22" class="cnblogs_code_hide">
<pre><code><span style="color: #008080;"> 1</span>         <span style="color: #008000;">//</span><span style="color: #008000;"> 遍历枚举 借助增强型for循环</span>
<span style="color: #008080;"> 2</span>         <span style="color: #0000ff;">for</span><span style="color: #000000;"> (Season season : Season.values())
</span><span style="color: #008080;"> 3</span> <span style="color: #000000;">        {
</span><span style="color: #008080;"> 4</span>             <span style="color: #0000ff;">switch</span><span style="color: #000000;"> (season)
</span><span style="color: #008080;"> 5</span> <span style="color: #000000;">            {
</span><span style="color: #008080;"> 6</span>                 <span style="color: #0000ff;">case</span><span style="color: #000000;"> SPRING:
</span><span style="color: #008080;"> 7</span>                     System.out.println("春天"<span style="color: #000000;">);
</span><span style="color: #008080;"> 8</span>                     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;"> 9</span>                 <span style="color: #0000ff;">case</span><span style="color: #000000;"> SUMMER:
</span><span style="color: #008080;">10</span>                     System.out.println("夏天"<span style="color: #000000;">);
</span><span style="color: #008080;">11</span>                     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">12</span>                 <span style="color: #0000ff;">case</span><span style="color: #000000;"> AUTUMN:
</span><span style="color: #008080;">13</span>                     System.out.println("秋天"<span style="color: #000000;">);
</span><span style="color: #008080;">14</span>                     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">15</span>                 <span style="color: #0000ff;">case</span><span style="color: #000000;"> WINTER:
</span><span style="color: #008080;">16</span>                     System.out.println("冬天"<span style="color: #000000;">);
</span><span style="color: #008080;">17</span>                     <span style="color: #0000ff;">break</span><span style="color: #000000;">;
</span><span style="color: #008080;">18</span>               
<span style="color: #008080;">19</span> <span style="color: #000000;">            }
</span><span style="color: #008080;">20</span>         }</code></pre>

<span class="cnblogs_code_collapse">View Code</span>
<h4>　　<strong>且，如果要简单的获取某个枚举中的变量，可以</strong></h4>
<src class="cnblogs_code">
<pre><code><span style="color: #008080;">1</span> 枚举类名 引用名 = 枚举类名.变量名;</code></pre>

<blockquote>
<p>　<strong>　补充：因为枚举中的均为常量，所以一般是全大写</strong></p>
</blockquote>
<p>&nbsp;　　</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>