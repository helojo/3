<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修Object类' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>Object类</center></div><div class='banquan'>原文出处:本文由博客园博主Classis_Man提供。<br/>
原文连接:https://www.cnblogs.com/Java-luan/p/11781448.html</div><br>
    <p>一、概述<br />Object类是所有Java类的祖先。每个类都使用 Object 作为超类。所有对象（包括数组）都实现这个类的方法。</p>
<p>Java 所有类都继承Object 但是没有用 extend 声明，是因为根据JDK版本不同，有的在编译器（JDK1.6）中实现，有的在VM中实现。</p>
<p>参考英文：<br />* Class {@code Object} is the root of the class hierarchy.<br />* Every class has {@code Object} as a superclass. All objects,<br />* including arrays, implement the methods of this class.</p>
<p>英文释义：<br />class hierarchy 类层次结构</p>
<p><br />二、object类中的方法</p>
<p>1、equals<br />判断两个对象是否相等，先判断引用类型是否相等，若相等再把字符串转为char[] 每个字符进行 比较，最终得出结果。</p>
<p>2、hashCode()<br />返回该对象的哈希码值。</p>
<p>hashcode的作用,以及重写equal方法,为什么要重写hashcode方法?<br />hashcode是系统用来快速检索对象而使用,equals方法是用来判断引用的对象是否一致,所以,当引用对象一致时,必须要确保其hashcode也一致,因此需要重写hashcode方法来确保这个一致性 。</p>
<p>3、getclass()</p>
<p>返回此&nbsp;<code>Object</code>&nbsp;的运行时类。</p>
<p>4、clone()</p>
<p>创建并返回此对象的一个副本。</p>
<p>5、toString()</p>
<p>返回该对象的字符串表示。</p>
<p>6、finalize()</p>
<p>当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。</p>
<p>7、notify()</p>
<p>唤醒在此对象监视器上等待的单个线程。</p>
<p>8、notifyAll()</p>
<p>唤醒在此对象监视器上等待的所有线程。</p>
<p>9、&nbsp;wait()</p>
<p>在其他线程调用此对象的&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notify()"><code>notify()</code></a>&nbsp;方法或&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notifyAll()"><code>notifyAll()</code></a>&nbsp;方法前，导致当前线程等待。</p>
<p>10、wait(long timeout)</p>
<p>在其他线程调用此对象的&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notify()"><code>notify()</code></a>&nbsp;方法或&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notifyAll()"><code>notifyAll()</code></a>&nbsp;方法，或者超过指定的时间量前，导致当前线程等待。</p>
<p>11、wait(long timeout, int nanos)</p>
<p>在其他线程调用此对象的&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notify()"><code>notify()</code></a>&nbsp;方法或&nbsp;<a href="file:///D:/zipfile/javazipfile/html_zh_CN/html/zh_CN/api/java/lang/Object.html#notifyAll()"><code>notifyAll()</code></a>&nbsp;方法，或者其他某个线程中断当前线程，或者已超过某个实际时间量前，导致当前线程等待。</p>
<p>三、方法详解</p>
<p><strong>1、equals()</strong><br />自反性（reflexive ）：对于任何非空引用值 x，x.equals(x) 都应返回 true。<br />对称性（symmetric ）：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。<br />传递性（transitive ）：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，那么 x.equals(z) 应返回 true。<br />一致性（consistent）：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，前提是对象上 equals 比较中所用的信息没有被修改。<br />对于任何非空引用值 x，x.equals(null) 都应返回 false。<br /><span style="background-color: #99cc00;"><strong>Object 类的 equals 方法实现对象上差别可能性最大的相等关系；即，对于任何非空引用值 x 和 y，当且仅当 x 和 y 引用同一个对象时，此方法才返回 true（x == y 具有值 true）。</strong></span><br /><span style="background-color: #99cc00;"><strong>注意：当此方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。</strong></span></p>
<p>以上特性，在进行equals方法的重写时，一定要遵守，否则容易出现一些意想不到的问题。这里就不一一举例了。</p>
<p>参考英文：<br />* Note that it is generally necessary to override the {@code hashCode}<br />* method whenever this method is overridden, so as to maintain the<br />* general contract for the {@code hashCode} method, which states<br />* that equal objects must have equal hash codes.</p>
<p>英文释义：<br />non-null reference value 非空引用值<br />multiple invocations 多次调用</p>
<p><strong>2、hashcode()</strong><br />返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。<br />hashCode 的常规协定是：</p>
<ul>
<li>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。</li>
<li>如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。</li>
<li>以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。</li>




</ul>
<p>实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）</p>
<p><strong>3、getclass()</strong></p>
<p><strong>返回此&nbsp;<code>Object</code>&nbsp;的运行时类。返回的&nbsp;<code>Class</code>&nbsp;对象是由所表示类的&nbsp;<code>static synchronized</code>&nbsp;方法锁定的对象。</strong></p>
<p><strong>4、clone()</strong></p>
<p><strong>创建并返回此对象的一个副本。&ldquo;副本&rdquo;的准确含义可能依赖于对象的类。这样做的目的是，对于任何对象&nbsp;<tt>x</tt>，表达式：</strong></p>
<blockquote>
<pre><code>x.clone() != x</code></pre>
</blockquote>
<p><strong>为 true，表达式：</strong></p>
<blockquote>
<pre><code>x.clone().getClass() == x.getClass()</code></pre>
</blockquote>
<p><strong>也为&nbsp;<tt>true。</tt></strong></p>
<p><tt>Object</tt>&nbsp;类的&nbsp;<tt>clone</tt>&nbsp;方法执行特定的复制操作。首先，如果此对象的类不能实现接口&nbsp;<tt>Cloneable</tt>，则会抛出&nbsp;<tt>CloneNotSupportedException</tt>。注意，所有的数组都被视为实现接口&nbsp;<tt>Cloneable</tt>。否则，此方法会创建此对象的类的一个新实例，并像通过分配那样，严格使用此对象相应字段的内容初始化该对象的所有字段；这些字段的内容没有被自我复制。所以，此方法执行的是该对象的&ldquo;浅表复制&rdquo;，而不&ldquo;深层复制&rdquo;操作。</p>
<p><tt>Object</tt>&nbsp;类本身不实现接口&nbsp;<tt>Cloneable</tt>，所以在类为&nbsp;<tt>Object</tt>&nbsp;的对象上调用&nbsp;<tt>clone</tt>&nbsp;方法将会导致在运行时抛出异常。</p>
<p><strong>5、toString()</strong></p>
<p><strong>返回该对象的字符串表示。通常，<code>toString</code>&nbsp;方法会返回一个&ldquo;以文本方式表示&rdquo;此对象的字符串。结果应是一个简明但易于读懂的信息表达式。建议所有子类都重写此方法。</strong></p>
<p><code>Object</code>&nbsp;类的&nbsp;<code>toString</code>&nbsp;方法返回一个字符串，该字符串由类名（对象是该类的一个实例）、at 标记符&ldquo;<code>@</code>&rdquo;和此对象哈希码的无符号十六进制表示组成。换句话说，该方法返回一个字符串，它的值等于：</p>
<blockquote>
<pre><code>getClass().getName() + '@' + Integer.toHexString(hashCode())</code></pre>
</blockquote>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>