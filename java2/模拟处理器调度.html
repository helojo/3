<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修模拟处理器调度' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>模拟处理器调度</center></div><div class='banquan'>原文出处:本文由博客园博主Contra_A提供。<br/>
原文连接:https://www.cnblogs.com/Contra-A/p/11823214.html</div><br>
    <p><strong>一、实习内容</strong></p>
<p>选择一个调度算法，实现处理器调度。</p>
<p><strong>二、实习目的</strong></p>
<p>在采用多道程序设计的系统中，往往有若干个进程同时处于就绪状态。当就绪进程个数大于处理器数时，就必须依照某种策略来决定哪些进程优先占用处理器。本实习模拟在单处理器情况下的处理器调度，帮助学生加深了解处理器调度的工作。</p>
<p><strong>三、实习题目</strong></p>
<p>本实习有两个题，学生可选择其中的一题做实习。</p>
<p>第一题：设计一个按优先数调度算法实现处理器调度的程序。</p>
<p>[提示]：</p>
<p>(1) 假定系统有五个进程，每一个进程用一个进程控制块PCB来代表，进程控制块的格式为：</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="156">
<p align="center">进程名</p>
</td>
</tr>
<tr>
<td valign="top" width="156">
<p align="center">指针</p>
</td>
</tr>
<tr>
<td valign="top" width="156">
<p align="center">要求运行时间</p>
</td>
</tr>
<tr>
<td valign="top" width="156">
<p align="center">优先数</p>
</td>
</tr>
<tr>
<td valign="top" width="156">
<p align="center">状态</p>
</td>
</tr>
</tbody>
</table>
<p>其中，进程名&mdash;&mdash;作为进程的标识，假设五个进程的进程名分别为P<sub>1</sub>，P<sub>2</sub>，P<sub>3</sub>，P<sub>4</sub>，P<sub>5</sub>。</p>
<p>指针&mdash;&mdash;按优先数的大小把五个进程连成队列，用指针指出下一个进程的进程控制块的首地址，最后一个进程中的指针为&ldquo;0&rdquo;。</p>
<p>要求运行时间&mdash;&mdash;假设进程需要运行的单位时间数。</p>
<p>优先数&mdash;&mdash;赋予进程的优先数，调度时总是选取优先数大的进程先执行。</p>
<p>状态&mdash;&mdash;可假设有两种状态，&ldquo;就绪&rdquo;状态和&ldquo;结束&rdquo;状态。五个进程的初始状态都为&ldquo;就绪&rdquo;，用&ldquo;R&rdquo;表示，当一个进程运行结束后，它的状态为&ldquo;结束&rdquo;，用&ldquo;E&rdquo;表示。</p>
<p>(2) 在每次运行你所设计的处理器调度程序之前，为每个进程任意确定它的&ldquo;优先数&rdquo;和&ldquo;要求运行时间&rdquo;。</p>
<p>(3) 为了调度方便，把五个进程按给定的优先数从大到小连成队列。用一单元指出队首进程，用指针指出队列的连接情况。例：</p>
<p>&nbsp;</p>
<p>&nbsp; 队首标志</p>
<p>&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;K<sub>2</sub>&nbsp;&nbsp;&nbsp;</p>
<table border="1" cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td valign="top" width="31">
<p>K<sub>1</sub></p>
</td>
<td valign="top" width="57">
<p align="center">P<sub>1</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;K<sub>2</sub></p>
</td>
<td valign="top" width="57">
<p align="center">P<sub>2</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;K<sub>3</sub></p>
</td>
<td valign="top" width="57">
<p align="center">P<sub>3</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;K<sub>4</sub></p>
</td>
<td valign="top" width="57">
<p align="center">P<sub>4</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;K<sub>5</sub></p>
</td>
<td valign="top" width="57">
<p align="center">P<sub>5</sub></p>
</td>
</tr>
<tr>
<td valign="top" width="31">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">0</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">K<sub>4</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">K<sub>5</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">K<sub>3</sub></p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">K<sub>1</sub></p>
</td>
</tr>
<tr>
<td valign="top" width="31">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">2</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">3</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">1</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">2</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">4</p>
</td>
</tr>
<tr>
<td valign="top" width="31">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">1</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">5</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">3</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">4</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">2</p>
</td>
</tr>
<tr>
<td valign="top" width="31">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">R</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">R</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">R</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">R</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">R</p>
</td>
</tr>
<tr>
<td valign="top" width="31">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">PCB1</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">PCB2</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">PCB3</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">PCB4</p>
</td>
<td valign="top" width="39">
<p>&nbsp;</p>
</td>
<td valign="top" width="57">
<p align="center">PCB5</p>
</td>
</tr>
</tbody>
</table>
<p>&nbsp;</p>
<p>(4) 处理器调度总是选队首进程运行。采用动态改变优先数的办法，进程每运行一次优先数就减&ldquo;1&rdquo;。由于本实习是模拟处理器调度，所以，对被选中的进程并不实际的启动运行，而是执行：</p>
<p align="center">优先数-1</p>
<p align="center">要求运行时间-1</p>
<p>来模拟进程的一次运行。</p>
<p>提醒注意的是：在实际的系统中，当一个进程被选中运行时，必须恢复进程的现场，让它占有处理器运行，直到出现等待事件或运行结束。在这里省去了这些工作。</p>
<p>(5) 进程运行一次后，若要求运行时间&sup1;0，则再将它加入队列（按优先数大小插入，且置队首标志）；若要求运行时间=0，则把它的状态修改成&ldquo;结束&rdquo;（E），且退出队列。</p>
<p>(6) 若&ldquo;就绪&rdquo;状态的进程队列不为空，则重复上面（4）和（5）的步骤，直到所有进程都成为&ldquo;结束&rdquo;状态。</p>
<p>(7) 在所设计的程序中应有显示或打印语句，能显示或打印每次被选中进程的进程名以及运行一次后进程队列的变化。</p>
<p>(8) 为五个进程任意确定一组&ldquo;优先数&rdquo;和&ldquo;要求运行时间&rdquo;，启动所设计的处理器调度程序，显示或打印逐次被选中进程的进程名以及进程控制块的动态变化过程。</p>
<p><span style="font-size: 18px;"><strong>&nbsp;C语言代码</strong></span></p>
<src class="cnblogs_code">
<pre><code>#include&lt;stdio.h&gt;<span style="color: #000000;">
#include</span>&lt;stdlib.h&gt;<span style="color: #000000;">
#include</span>&lt;<span style="color: #0000ff;">string</span>.h&gt;
<span style="color: #0000ff;">struct</span><span style="color: #000000;"> pcb
{
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;"> name;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> num;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;">  priority;        
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;">  runtime;    
    </span><span style="color: #0000ff;">char</span><span style="color: #000000;">  state;     
};
typedef </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> node
{
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> pcb data;
    </span><span style="color: #0000ff;">struct</span> node*<span style="color: #000000;"> next;
}Node;
</span><span style="color: #0000ff;">int</span> w=<span style="color: #800080;">1</span><span style="color: #000000;">;
</span><span style="color: #0000ff;">void</span> creat(Node *h,<span style="color: #0000ff;">int</span> n)<span style="color: #008000;">//</span><span style="color: #008000;">创建链表 </span>
<span style="color: #000000;">{
    Node </span>*<span style="color: #000000;">p;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;    
    </span><span style="color: #0000ff;">for</span>(i=<span style="color: #800080;">0</span>;i&lt;n;i++<span style="color: #000000;">)
    {
        p</span>=(Node *)malloc(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
        p</span>-&gt;data.name=<span style="color: #800000;">'</span><span style="color: #800000;">p</span><span style="color: #800000;">'</span><span style="color: #000000;">;          
        p</span>-&gt;data.num=w++<span style="color: #000000;">;
        p</span>-&gt;data.priority=rand() % <span style="color: #800080;">5</span>  + <span style="color: #800080;">1</span><span style="color: #000000;">;
        p</span>-&gt;data.runtime=rand() % <span style="color: #800080;">5</span>  + <span style="color: #800080;">1</span><span style="color: #000000;">;
        p</span>-&gt;data.state=<span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        h</span>-&gt;next=<span style="color: #000000;">p;
        h</span>=<span style="color: #000000;">p;
    }
    h</span>-&gt;next=<span style="color: #000000;">NULL;
}
</span><span style="color: #0000ff;">void</span> output(Node *h)<span style="color: #008000;">//</span><span style="color: #008000;">打印链表 </span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i;
    Node </span>*<span style="color: #000000;">p;
    p</span>=h-&gt;<span style="color: #000000;">next;
     printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">\n进程名   优先级     运行时间     进程状态 \n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
    </span><span style="color: #0000ff;">while</span>(p!=<span style="color: #000000;">NULL)
    {
           printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%c%d %8d  %8d    %10c\n</span><span style="color: #800000;">"</span>, p-&gt;data.name,p-&gt;data.num, p-&gt;data.priority, p-&gt;data.runtime,p-&gt;<span style="color: #000000;">data.state);    
        </span><span style="color: #0000ff;">if</span>(p-&gt;next!=<span style="color: #000000;">NULL){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">下一个指向：%c%d\n</span><span style="color: #800000;">"</span>,p-&gt;next-&gt;data.name,p-&gt;next-&gt;<span style="color: #000000;">data.num);
            }    
        </span><span style="color: #0000ff;">if</span>(p-&gt;next==<span style="color: #000000;">NULL){
            printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">下一个指向：%s\n</span><span style="color: #800000;">"</span><span style="color: #000000;">,NULL);
            }
        p</span>=p-&gt;<span style="color: #000000;">next;            
    }   
}
</span><span style="color: #0000ff;">int</span> lenList(Node *<span style="color: #000000;">h)
{
    </span><span style="color: #0000ff;">if</span> (h ==<span style="color: #000000;"> NULL)
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
    Node </span>*p =<span style="color: #000000;"> h;
    </span><span style="color: #0000ff;">int</span> len = <span style="color: #800080;">0</span><span style="color: #000000;">;
    </span><span style="color: #0000ff;">while</span>(p !=<span style="color: #000000;"> NULL)
    {
        len</span>++<span style="color: #000000;">;
        p </span>= p-&gt;<span style="color: #000000;">next;
    }
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> len;
}

</span><span style="color: #0000ff;">void</span> insert(Node *h)<span style="color: #008000;">//</span><span style="color: #008000;">表尾插入结点 </span>
<span style="color: #000000;">{
Node </span>*<span style="color: #000000;">p;
</span><span style="color: #0000ff;">while</span>(h-&gt;next!=<span style="color: #000000;">NULL)     
    {    
        h</span>=h-&gt;<span style="color: #000000;">next;
    }
    p</span>=(Node *)malloc(<span style="color: #0000ff;">sizeof</span>(Node)); <span style="color: #008000;">//</span><span style="color: #008000;">分配空间</span>
     p-&gt;data.name=<span style="color: #800000;">'</span><span style="color: #800000;">p</span><span style="color: #800000;">'</span><span style="color: #000000;">;          
    p</span>-&gt;data.num=w++<span style="color: #000000;">;
    p</span>-&gt;data.priority=rand() % <span style="color: #800080;">5</span>  + <span style="color: #800080;">1</span><span style="color: #000000;">;
    p</span>-&gt;data.runtime=rand() % <span style="color: #800080;">5</span>  + <span style="color: #800080;">1</span><span style="color: #000000;">;
    p</span>-&gt;data.state=<span style="color: #800000;">'</span><span style="color: #800000;">R</span><span style="color: #800000;">'</span><span style="color: #000000;">;
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">新加了一个进程：%c%d\n</span><span style="color: #800000;">"</span>,p-&gt;data.name,p-&gt;<span style="color: #000000;">data.num);
    h</span>-&gt;next=<span style="color: #000000;">p;
    p</span>-&gt;next=<span style="color: #000000;">NULL;                    
}
</span><span style="color: #0000ff;">void</span> sortList(Node *h)<span style="color: #008000;">//</span><span style="color: #008000;">链表排序 </span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span> len =<span style="color: #000000;"> lenList(h);    
    </span><span style="color: #0000ff;">if</span> (len == <span style="color: #800080;">0</span><span style="color: #000000;">)
    </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
    Node </span>*p =<span style="color: #000000;"> h;
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> i, j;
    </span><span style="color: #0000ff;">struct</span><span style="color: #000000;"> pcb tmp;
    </span><span style="color: #0000ff;">for</span> (i = <span style="color: #800080;">0</span>; i &lt; len - <span style="color: #800080;">1</span>; i++<span style="color: #000000;">)
    {
        p </span>=<span style="color: #000000;"> h;
        </span><span style="color: #0000ff;">for</span> (j = <span style="color: #800080;">0</span>; j &lt; len -i -<span style="color: #800080;">1</span>; j++<span style="color: #000000;">)
        {
            </span><span style="color: #0000ff;">if</span> (p-&gt;data.priority &lt; p-&gt;next-&gt;<span style="color: #000000;">data.priority)
            {
                tmp </span>= p-&gt;<span style="color: #000000;">data;
                p</span>-&gt;data = p-&gt;next-&gt;<span style="color: #000000;">data;
                p</span>-&gt;next-&gt;data =<span style="color: #000000;"> tmp;
                    
            }
            </span><span style="color: #0000ff;">if</span>(p-&gt;data.priority == p-&gt;next-&gt;<span style="color: #000000;">data.priority)
            {
                </span><span style="color: #0000ff;">if</span>(p-&gt;data.runtime &gt; p-&gt;next-&gt;<span style="color: #000000;">data.runtime)
                {
                    tmp </span>= p-&gt;<span style="color: #000000;">data;
                    p</span>-&gt;data = p-&gt;next-&gt;<span style="color: #000000;">data;
                    p</span>-&gt;next-&gt;data =<span style="color: #000000;"> tmp;
                }                
            }
            p </span>= p-&gt;<span style="color: #000000;">next;
        }
    }
}
</span><span style="color: #0000ff;">void</span> ListDelete(Node *h)<span style="color: #008000;">//</span><span style="color: #008000;">删除首结点 </span>
<span style="color: #000000;">{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> j;
    Node</span>* p,*<span style="color: #000000;">q;
    p</span>=<span style="color: #000000;">h;
    q</span>=p-&gt;<span style="color: #000000;">next;
    p</span>-&gt;next=q-&gt;<span style="color: #000000;">next;   
    free(q);   
}
</span><span style="color: #0000ff;">void</span> run(Node* h)<span style="color: #008000;">//</span><span style="color: #008000;">运行 </span>
<span style="color: #000000;">{
    Node </span>*<span style="color: #000000;">p;
    p</span>=h-&gt;<span style="color: #000000;">next;
    p</span>-&gt;data.priority--<span style="color: #000000;">;
    p</span>-&gt;data.runtime--<span style="color: #000000;">;
    </span><span style="color: #0000ff;">if</span>(p-&gt;data.runtime==<span style="color: #800080;">0</span><span style="color: #000000;">)
    {
        p</span>-&gt;data.state=<span style="color: #800000;">'</span><span style="color: #800000;">E</span><span style="color: #800000;">'</span><span style="color: #000000;">;
        ListDelete(h);            
    }        
    </span><span style="color: #0000ff;">if</span>(rand()%<span style="color: #800080;">5</span>&gt;<span style="color: #800080;">3</span><span style="color: #000000;">)
    {
        insert(h);
    }
    sortList(h);    
}

</span><span style="color: #0000ff;">void</span><span style="color: #000000;"> main()
{
    </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> n;
    Node </span>*<span style="color: #000000;">h;
    printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">请输入进程数：\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);    
    scanf(</span><span style="color: #800000;">"</span><span style="color: #800000;">%d</span><span style="color: #800000;">"</span>,&amp;<span style="color: #000000;">n);   
    h</span>=(Node *)malloc(<span style="color: #0000ff;">sizeof</span><span style="color: #000000;">(Node));
    h</span>-&gt;next=<span style="color: #000000;">NULL;
    creat(h,n);
    sortList(h);
    </span><span style="color: #0000ff;">while</span>(h-&gt;next!=<span style="color: #000000;">NULL)
    {                            
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">********************************\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">运行前：</span><span style="color: #800000;">"</span><span style="color: #000000;">); 
        output(h);
        run(h);
    
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">运行后：</span><span style="color: #800000;">"</span><span style="color: #000000;">);
        output(h);
        printf(</span><span style="color: #800000;">"</span><span style="color: #800000;">********************************\n</span><span style="color: #800000;">"</span><span style="color: #000000;">);                                                                                             
    }    
}</span></code></pre>

<p>&nbsp;</p>
<p>&nbsp;</p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>