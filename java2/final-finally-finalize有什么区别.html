<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修final-finally-finalize有什么区别' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>final-finally-finalize有什么区别</center></div><div class='banquan'>原文出处:本文由博客园博主你个小秃头提供。<br/>
原文连接:https://www.cnblogs.com/dmzna/p/11830602.html</div><br>
    <pre><code></code></pre>
<h4 class="md-end-block md-heading"><span class="md-plain">一、final</span></h4>
<p class="md-end-block md-p"><span class="md-plain">1.final用于声明属性、方法和类，分别表示属性不可变，方法不可覆盖类和类不可能被继承（不可能再派生出新的子类）。</span></p>
<p class="md-end-block md-p md-focus"><span class="md-plain md-expand">final属性：被final修饰的变量不可变。</span></p>
<p class="md-end-block md-p"><span class="md-plain">1）.引用不可变</span></p>
<p class="md-end-block md-p"><span class="md-plain">2）.对象不可变</span></p>
<p class="md-end-block md-p"><span class="md-plain">1.final在定义的时候初始化。</span></p>
<p class="md-end-block md-p"><span class="md-plain">2.final成员变量可以再初始化块中初始化，不能在静态初始化块中初始化。</span></p>
<p class="md-end-block md-p"><span class="md-plain">3.静态final成员变量可以在静态初始化中初始化但不可以在初始化块中初始化。</span></p>
<p class="md-end-block md-p"><span class="md-plain">4.类的构造器中初始化，但静态final成员变量不可以在构造函数中初始化</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">class <span class="cm-def">finaltest {<br /><span><span class="cm-tab">    <span class="cm-keyword">public <span class="cm-keyword">static <span class="cm-variable-3">void <span class="cm-variable">main(<span class="cm-variable-3">String[] <span class="cm-variable">args) {<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-keyword">final <span class="cm-variable-3">StringBuffer <span class="cm-variable">stringBuffer<span class="cm-operator">=<span class="cm-keyword">new <span class="cm-variable-3">StringBuffer(<span class="cm-string">"hello");<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">stringBuffer.<span class="cm-variable">append(<span class="cm-string">" word");<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">System.<span class="cm-variable">out.<span class="cm-variable">println(<span class="cm-variable">stringBuffer);<br /><span><span class="cm-tab">    }<br /><span>​<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p class="md-end-block md-p"><span class="md-plain">运行结果：hello word</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-keyword">public <span class="cm-keyword">class <span class="cm-def">finaltest {<br /><span><span class="cm-tab">    <span class="cm-keyword">public <span class="cm-keyword">static <span class="cm-variable-3">void <span class="cm-variable">main(<span class="cm-variable-3">String[] <span class="cm-variable">args) {<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-keyword">final <span class="cm-variable-3">StringBuffer <span class="cm-variable">stringBuffer<span class="cm-operator">=<span class="cm-keyword">new <span class="cm-variable-3">StringBuffer(<span class="cm-string">"hello");<br /><span> &nbsp; &nbsp; &nbsp; &nbsp;<span class="cm-variable">stringBuffer <span class="cm-operator">=<span class="cm-keyword">new <span class="cm-variable-3">StringBuffer(<span class="cm-string">"hello word");<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">System.<span class="cm-variable">out.<span class="cm-variable">println(<span class="cm-variable">stringBuffer);<br /><span><span class="cm-tab">    }<br /><span>​<br /><span>}</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p class="md-end-block md-p"><span class="md-plain">编译期间报错。</span></p>
<p class="md-end-block md-p"><span class="md-plain">final方法：当一个方法声明为final时，该方法不允许任何子类重写这个方法，但子类仍然可以使用这个方法。</span></p>
<p class="md-end-block md-p"><span class="md-plain">final参数：用来表示这个参数在函数内部不允许修改。</span></p>
<p class="md-end-block md-p"><span class="md-plain">final类：当一个类被声明为final时，此类不能被继承，所有方法都不能被重写。</span></p>
<p class="md-end-block md-p"><span class="md-plain">一个类既不能被声明为abstract，又被声明为final。</span></p>
<h4 class="md-end-block md-heading"><span class="md-plain">二、finally</span></h4>
<p class="md-end-block md-p"><span class="md-plain">finally作为异常处理的一部分，他只能使用于try/catch语句中，并且附带一个语句块，表示这个语句块最终一定被执行，经常使用与需要释放资源的情况下。</span></p>
<pre class="md-fences md-end-block ty-contain-cm modeLoaded"><span><span class="cm-variable">Connection <span class="cm-variable">conn;<br /><span><span class="cm-variable">Statement <span class="cm-variable">stmt;<br /><span><span class="cm-tab">    <span class="cm-keyword">try{<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">conn<span class="cm-operator">=<span class="cm-variable">DriverMannager.<span class="cm-variable">getConnection(<span class="cm-variable">url,<span class="cm-variable">username,<span class="cm-variable">password);<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">stmt<span class="cm-operator">=<span class="cm-variable">conn.<span class="cm-variable">createStatement();<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">stmt.<span class="cm-variable">executeUpdate(<span class="cm-variable">sql);<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">stmt.<span class="cm-variable">close();<br /><span><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">conn.<span class="cm-variable">close();<br /><span><span class="cm-tab">    <span class="cm-keyword">catch (<span class="cm-variable">Exception <span class="cm-variable">e) {<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-comment">// TODO: handle exception<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-variable">System.<span class="cm-variable">out.<span class="cm-variable">println(<span class="cm-variable">e);<br /><span><span class="cm-tab">    }<span class="cm-variable">fianlly{<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-keyword">if(<span class="cm-variable">stmt<span class="cm-operator">!=<span class="cm-variable">NUll)<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-variable">stmt.<span class="cm-variable">close();<br /><span><span class="cm-tab">    <span class="cm-tab">    <span class="cm-keyword">if(<span class="cm-variable">conn<span class="cm-operator">!=<span class="cm-variable">NUll)<br /><span class="cm-tab-wrap-hack"><span class="cm-tab">     &nbsp; &nbsp;<span class="cm-variable">conn.<span class="cm-variable">close();<span class="cm-tab">   <br /><span><span class="cm-tab">    }<br /><span>}<br /><span>​</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<h4 class="md-end-block md-heading"><span class="md-plain">三、finalize　　</span></h4>
<p class="md-end-block md-p"><span class="md-plain">　　finalize()是在java.lang.Object里定义的，也就是说每一个对象都有这么个方法。这个方法在gc启动，该对象被回收的时候被调用。其实gc可以回收大部分的对象（凡是new出来的对象，gc都能搞定，一般情况下我们又不会用new以外的方式去创建对象），所以一般是不需要程序员去实现finalize的。 <span class="md-softbreak"> <span class="md-plain">特殊情况下，需要程序员实现finalize，当对象被回收的时候释放一些资源，比如：一个socket链接，在对象初始化时创建，整个生命周期内有效，那么就需要实现finalize，关闭这个链接。 <span class="md-softbreak"> <span class="md-plain">　　使用finalize还需要注意一个事，调用super.finalize();</span></span></span></span></span></p>
<p class="md-end-block md-p"><span class="md-plain md-expand">　　一个对象的finalize()方法只会被调用一次，而且finalize()被调用不意味着gc会立即回收该对象，所以有可能调用finalize()后，该对象又不需要被回收了，然后到了真正要被回收的时候，因为前面调用过一次，所以不会调用finalize()，产生问题。 所以，推荐不要使用finalize()方法，它跟析构函数不一样。</span></p>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>