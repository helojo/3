<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修各种设计模式的简单介绍' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>各种设计模式的简单介绍</center></div><div class='banquan'>原文出处:本文由博客园博主镇屌提供。<br/>
原文连接:https://www.cnblogs.com/zhendiao/p/11774049.html</div><br>
    <h2 id="设计模式的六大原则">设计模式的六大原则</h2>
<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
<li>开闭原则</li>
</ul>
<h2 id="设计模式的分类">设计模式的分类</h2>
<h3 id="创建型模式">创建型模式</h3>
<p>创建型模式：对对象实例化的抽象，通过采用抽象类所定义的接口，封装了系统中对象如何创建，组合等信息。包括以下几种设计模式</p>
<h4 id="抽象工厂模式">抽象工厂模式</h4>
<h5 id="优点">优点</h5>
<blockquote>
<ul>
<li>分离了具体类</li>
<li>更容易在产品系列中进行转换</li>
<li>提高了产品间一致性</li>
</ul>
</blockquote>
<h5 id="缺点">缺点</h5>
<blockquote>
<ul>
<li>难以支持新的产品等级结构</li>
<li>支持新的产品等级结构就要扩展原来的抽象工厂接口</li>
</ul>
</blockquote>
<h5 id="适用场景">适用场景</h5>
<blockquote>
<ul>
<li>系统独立于产品的创建，组成以及表示</li>
<li>系统配置成具有多个产品的系列</li>
<li>当要强调一系列相关的产品对象的设计便于进行联合使用时</li>
<li>当提供一个产品类库，而只想显示它们的接口而不是实现时</li>
</ul>
</blockquote>
<h5 id="应用举例">应用举例</h5>
<blockquote>
<p>在很多软件系统中需要更换界面主题，要求界面中的按钮，文本框，背景色等一起发生改变时可以使用抽象工厂模式进行设计</p>
</blockquote>
<h4 id="构建器模式">构建器模式</h4>
<h5 id="优点-1">优点</h5>
<blockquote>
<ul>
<li>产品的内部表象可以独立变化</li>
<li>将构建代码与表示代码相分离，可以使客户端不必知道产品内部组成的细节</li>
</ul>
</blockquote>
<h5 id="缺点-1">缺点</h5>
<blockquote>
<ul>
<li>构建器模式创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间差异性很大。则不适合使用构建器模式</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大</li>
</ul>
</blockquote>
<h5 id="适用场景-1">适用场景</h5>
<blockquote>
<p>创建复杂对象的算法独立于组成对象的部分以及这些部分的集合方式<br />
构造过程必须允许已构建对象有不同表示</p>
</blockquote>
<h5 id="应用举例-1">应用举例</h5>
<blockquote>
<p>在很多游戏软件中，地图包括天空，地面背景等组成部分，人物角色包括人体，服装，装备等组成部分，可以使用建造者模式对其进行设计，通过不同的具体建造者创建不同类型的地图或人物</p>
</blockquote>
<h4 id="工厂方法模式">工厂方法模式</h4>
<p>定义一个用于创建对象(产品)的接口，由子类决定实例化那个类的对象（ 产品）</p>
<h5 id="优点-2">优点</h5>
<ul>
<li>没有了将应用程序绑定到代码中的要求，代码只处理接口，因此可以使用任何实现了接口的类</li>
<li>允许子类提供对象的扩展版本</li>
<li>符合迪米特法则，依赖倒置原则，里氏替换原则</li>
</ul>
<h5 id="缺点-2">缺点</h5>
<ul>
<li>需要Creator和相应的子类作为工厂方法的载体，如果应用模型确实需要creator的子类存在，则很好，否则需要增加一个类层次</li>
</ul>
<h5 id="适用场景-2">适用场景</h5>
<ul>
<li>当一个类不知道他所创建的产品的具体是那个子类时</li>
<li>当创建对象的过程希望延缓到子类中进行时</li>
<li><p>类希望子类指定他要创建的对象</p>
<h4 id="应用举例-2">应用举例</h4>
<p>Windows的COM组件与MFC</p>
<h4 id="原型模式">原型模式</h4>
<p>指定创建对象的种类，并且通过拷贝这些原型创建新的对象，以一个已有的对象作为原型，通过他来创建新对象</p>
<h5 id="优点-3">优点</h5></li>
<li>可以在允许时添加或删除产品</li>
<li>原型模式提供简化的创建结构</li>
<li>具有给一个应用软件加载新功能的能力</li>
<li><p>产品类不需要非得由任何实现确定的等级结构</p></li>
</ul>
<h5 id="缺点-3">缺点</h5>
<p>每一个类必须配备一个克隆方法</p>
<h5 id="适用场景-3">适用场景</h5>
<ul>
<li>在运行时，指定需要实例化的类，例如动态载入，避免构建与产品的类层次结构相似的共产类层次结构</li>
<li><p>当类的实例是仅有的一些不同状态组合</p>
<h4 id="单例模式">单例模式</h4>
<p>一个类只有一个实例</p>
<h5 id="优点-4">优点</h5></li>
<li>对单个实例的受控制访问</li>
<li>名称空间减少</li>
<li>允许改进操作和表示</li>
<li>允许可变数目的实例</li>
<li><p>比类操作更灵活</p></li>
</ul>
<h5 id="缺点-4">缺点</h5>
<p>单例类的扩展有很大困难，且职责过重，这在一定程度上违背了单一职责原则</p>
<h5 id="适用场景-4">适用场景</h5>
<p>只有一个类实例</p>
<h5 id="应用举例-3">应用举例</h5>
<p>逐渐生成器</p>
<h3 id="结构型模式">结构型模式</h3>
<p>主要用于如何组合已有的类和对象以获得更大的结构，它采用继承机制组合接口来实现，以提供 统一的外部试图或新的功能</p>
<h4 id="适配器模式">适配器模式</h4>
<p>将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本的接口不兼容而不能一起工作的那些类可以一起工作</p>
<h5 id="优点-5">优点</h5>
<ul>
<li>允许两个或多个不兼容的对象进行交互和通信</li>
<li>提高已有功能的重复适用</li>
<li>增加了类的透明度</li>
<li>灵活性</li>
</ul>
<h5 id="缺点-5">缺点</h5>
<p>过多的适用适配器会让系统非常凌乱，不易整体进行把握</p>
<h5 id="适用场景-5">适用场景</h5>
<ul>
<li>要使用已有的类，而该类接口与所需的接口并不匹配</li>
<li>要创建可重复使用的类，该类可以与不相干或未知类进行协助，即类之间不需要兼容接口</li>
<li>要在一个不同于已知接口的接口环境重使用对象</li>
<li>必须要进行多个源之间的接口转换的时候</li>
</ul>
<h5 id="应用举例-4">应用举例</h5>
<p>在.Net重有一个类库已经实现的，非常重要的适配器——Data Adapter</p>
<h4 id="桥接模式">桥接模式</h4>
<p>将一个辅助的组件分成两个独立的但又相关的继承层次结构</p>
<h5 id="优点-6">优点</h5>
<ul>
<li>可以将接口与是实现相分离</li>
<li>提高可扩展性</li>
<li><p>对客户端隐藏了实现细节</p>
<h5 id="缺点-6">缺点</h5></li>
<li>增加了系统的理解和设计难度</li>
<li><p>要求正确的识别出系统重两个独立变化的维度，因此其使用范围有一定的局限性</p></li>
</ul>
<h5 id="适用场景-6">适用场景</h5>
<ul>
<li>想避免在抽象及其实现之间存在永久的绑定</li>
<li>抽象及其实现可以使用子类进行扩展</li>
<li>抽象的实现被改动应该对客户端没有影响</li>
</ul>
<h4 id="组合模式">组合模式</h4>
<p>将对象组合成树型结构以表示“部分-整体”的层次结构</p>
<h5 id="优点-7">优点</h5>
<ul>
<li>清楚的定义分层次的复杂对象，表示对象的全部或部分层次</li>
<li>使得增加新构件 更容易了了</li>
<li>提高了结构的灵活性和可管理的接口</li>
</ul>
<h5 id="缺点-7">缺点</h5>
<p>使设计变得更加抽象。如果对象的业务规则很复杂，则实现组合模式具有很大的挑战性，而且不是所有的方法都与叶子对象子类有关联</p>
<h5 id="适用场景-7">适用场景</h5>
<ul>
<li>想表示对象的部分--整体层次结构</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一的使用组合结构重的所有对象</li>
<li><p>结构可以具有任何级别的复杂性，而且是动态的</p>
<h5 id="应用举例-5">应用举例</h5>
<p>部分、整体场景如树型菜单，文件，文件夹的管理</p></li>
</ul>
<h4 id="装饰模式">装饰模式</h4>
<p>动态的给对象添加一些额外的责任，就增加功能来说，装饰比生成子类更为灵活</p>
<h5 id="优点-8">优点</h5>
<ul>
<li>比静态继承具有更大的灵活性</li>
<li>简化代码</li>
<li>改进对象的扩展性，用户可以通过编写新的类来做出改变</li>
<li>装饰类和被装饰类可以独立发展，不会相互耦合</li>
</ul>
<h5 id="缺点-8">缺点</h5>
<p>多层装饰比较复杂</p>
<h5 id="适用场景-8">适用场景</h5>
<ul>
<li>想要在单个对象动态并且透明的添加责任，而这样不会影响其他对象</li>
<li>想要在以后可能要修改的对象重添加责任</li>
<li>当无法通过静态子类化实现扩展时</li>
</ul>
<h4 id="外观模式">外观模式</h4>
<p>为子系统重的一组接口提供一个统一的接口，外观模式通过一个高层接口隔离了外部系统与子系统间复杂的交互过程，使得复杂系统的子系统更容易使用</p>
<h5 id="优点-9">优点</h5>
<ul>
<li>在不减少系统所提供的选项的情况下，为复杂系统提供了简单的接口</li>
<li>客户端屏蔽了子系统组件</li>
<li>提高了子系统和其客户端之间的弱耦合度</li>
<li>将客户端请求转发后能够处理这些请求的子系统</li>
</ul>
<h5 id="缺点-9">缺点</h5>
<ul>
<li>不能很好的限制客户使用子系统类，如果对客户访问子系统做太多的限制，则减少了可变性和灵活性</li>
<li>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了开闭原则</li>
</ul>
<h5 id="适用场景-9">适用场景</h5>
<ul>
<li>为一个复杂子系统提供一个简单接口时</li>
<li>客户程序与抽象类的实现之间存在着很大的依赖性</li>
<li>构建一个层次结构的子系统时，适用Facade模式定义子系统中每层的入口点，如果子系统之间是相互依赖的，你可以让他们仅通过Facade进行通信，从而简化了他们之间的依赖关系</li>
</ul>
<h4 id="享元模式">享元模式</h4>
<p>通过共享对象减少系统中低等级的，详细的对象数目</p>
<h5 id="优点-10">优点</h5>
<ul>
<li>减少了要处理的对象数目</li>
<li>如果对象能够持续，可以减少内存和存储设备</li>
</ul>
<h5 id="缺点-10">缺点</h5>
<ul>
<li>使得应用程序在某种程度上来说更加复杂化了</li>
<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长</li>
</ul>
<h5 id="适用场景-10">适用场景</h5>
<ul>
<li>应用程序使用大量的对象</li>
<li>由于对象数目巨大，导致很高的存储开销</li>
<li>应用程序不依赖于对象的身份</li>
</ul>
<h4 id="代理模式">代理模式</h4>
<p>为控制初始对象的访问，提供了一个代理或者占位符对象</p>
<h5 id="优点-11">优点</h5>
<ul>
<li>远程代理可以隐藏对象位于不同的地址空间的事实</li>
<li><p>虚拟代理可以执行优化操作</p>
<h5 id="缺点-11">缺点</h5></li>
<li>请求的处理速度变慢</li>
<li><p>实现代理模式需要额外的工作，从而增加了系统实现的复杂度</p>
<h5 id="适用场景-11">适用场景</h5></li>
<li>当需要为了一个对象在不同的地址空间提供局部的代表时</li>
<li><p>当需要创建开销非常大的对象时</p>
<h5 id="应用举例-6">应用举例</h5>
<p>防火墙代理---保护目标不让恶意用户靠近</p></li>
</ul>
<h3 id="行为型模型">行为型模型</h3>
<p>从大量的实际行动中概括出来作为行为的理论抽象、基本框架和标准，该类模式主要用于对象之间的职责及其提供的服务的分配，他不仅描述对象或类的模式，还描述它们之间的通信模式</p>
<h4 id="责任链模式">责任链模式</h4>
<p>在系统中建立一个链，消息可以首先接收到他的级别被处理，或者定位到可以处理他的对象</p>
<h5 id="优点-12">优点</h5>
<ul>
<li>降低耦合度</li>
<li>增加向对象指定责任的灵活性</li>
</ul>
<h5 id="适用场景-12">适用场景</h5>
<ul>
<li>多个对象可以处理一个请求，而其处理器却是未知的</li>
<li>可以动态指定能够处理请求的对象集</li>
</ul>
<h4 id="命令模式">命令模式</h4>
<p>在对象中封装请求，保存命令并传递给方法以及任何其他对象一样返回该命令</p>
<h5 id="优点-13">优点</h5>
<ul>
<li>添加新命令不用修改已有类</li>
<li>将操作对象与知道如何完成操作的对象相分离</li>
</ul>
<h5 id="适用场景-13">适用场景</h5>
<ul>
<li>想要通过要执行的动作来参数化对象</li>
<li>在不同的时间指定、排序以及执行请求</li>
</ul>
<h4 id="解释器模式">解释器模式</h4>
<p>解释定义其语法表示的语言</p>
<h5 id="优点-14">优点</h5>
<ul>
<li>容易修改并扩展语法</li>
<li>容易实现语法</li>
</ul>
<h5 id="适用场景-14">适用场景</h5>
<ul>
<li>语言的语法比较简单</li>
<li>效率并不是最主要的问题</li>
</ul>
<h4 id="迭代器模式">迭代器模式</h4>
<p>提供一种方法顺序的访问一个聚合对象中的各个元素，而又不暴露改对象的内部表示</p>
<h5 id="优点-15">优点</h5>
<ul>
<li>支持集合的不同遍历</li>
<li>简化集合接口</li>
</ul>
<h5 id="适用场景-15">适用场景</h5>
<ul>
<li>在不开放集合内部对象表示的前提下访问集合对象内容</li>
<li>支持记号个对象的多重遍历</li>
<li>为遍历集合中的不同结构提供了统一的接口</li>
</ul>
<h4 id="备忘录模式">备忘录模式</h4>
<p>保持对象状态的“快照”，在不向外界公开其内容的情况下返回到它的最初状态</p>
<h5 id="优点-16">优点</h5>
<ul>
<li>保持封装完整</li>
<li>简化了返回到初始状态所需的操作</li>
</ul>
<h5 id="适用场景-16">适用场景</h5>
<ul>
<li>必须保存对象的快照</li>
<li>适用直接接口来获得状态有可能会公开对象的实现细节，从而破坏对象的封装性</li>
</ul>
<h4 id="观察者模式">观察者模式</h4>
<p>为组件向相关接收方广播消息提供了灵活的方法</p>
<h5 id="优点-17">优点</h5>
<ul>
<li>抽象了主体与Observer 之间的耦合关系</li>
<li>支持广播方式的通信</li>
</ul>
<h4 id="适用场景-17">适用场景</h4>
<ul>
<li>对一个对象的修改涉及其他对象的修改，而不知道有多少对象需要修改</li>
<li>对象应该能在不设置对象标识的情况下通知其他对象</li>
</ul>
<h4 id="状态模式">状态模式</h4>
<p>允许对象在内部状态变化时变更其行为，并且修改其类</p>
<h5 id="优点-18">优点</h5>
<ul>
<li>定位指定状态的行为，并根据不同的状态来划分行为</li>
</ul>
<h5 id="适用场景-18">适用场景</h5>
<ul>
<li>对象行为依赖于其状态，且对象必须在运行时根据其状态修改行为</li>
<li>操作具有大量以及多部份组成的取决于对象状态的条件语句</li>
</ul>
<h4 id="策略模式">策略模式</h4>
<p>定义了一组用来表示可能行为集合的类</p>
<h5 id="优点-19">优点</h5>
<ul>
<li>另一种子类化方法</li>
<li>在类自身中定义行为，减少条件语句</li>
<li>更容易扩展模型</li>
</ul>
<h5 id="适用场景-19">适用场景</h5>
<ul>
<li>许多相关类只是在行文方面有所区别</li>
<li>需要算法的不同变体</li>
<li>算法使用客户端未知的数据</li>
</ul>
<h4 id="模板方法模式">模板方法模式</h4>
<p>提供了在不重写方法的前提下允许子类重载部分方法的方法</p>
<h5 id="优点-20">优点</h5>
<ul>
<li>代码使用</li>
</ul>
<h5 id="适用场景-20">适用场景</h5>
<ul>
<li>想要一次实现算法的不变部分，适用子类实现算法的可变行为</li>
<li>子类间通用行为需要分解，定位到通用类，可以避免代码重复问题</li>
</ul>
<h4 id="访问者模式">访问者模式</h4>
<p>提供了一种方便的，可维护的方法来表示在对象结构元素上进行的操作。改模式允许在不改变操作元素的类的前提下定义一个新操作</p>
<h5 id="优点-21">优点</h5>
<ul>
<li>容易添加新操作</li>
<li><p>集中相关操作并且排除不相关操作</p>
<h5 id="适用场景-21">适用场景</h5></li>
<li>定义对象结构的类很少被修改，但想要在此结构上定义新的操作</li>
<li><p>对象结构包含许多具有不同接口的对象类，并且想要对这些依赖于具体的类的对象进行操作</p></li>
</ul>
<h4 id="中介者模式">中介者模式</h4>
<p>通过引入一个能够管理对象间消息分布的对象，简化系统中对象的通信</p>
<h5 id="优点-22">优点</h5>
<ul>
<li>取出对象间的影响</li>
<li>简化对象间的协议</li>
<li>集中化控制</li>
</ul>
<h5 id="适用场景-22">适用场景</h5>
<ul>
<li>对象集合需要一个定义但复杂的方式进行通信</li>
<li>想要在不使用子类的情况下自定义分布在几个对象间的行为</li>
</ul>
<blockquote>
<p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom">OpenWrite</a> 发布！</p>
</blockquote>


</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>