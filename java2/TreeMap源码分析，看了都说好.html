<html><head><meta charset='utf-8'><meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='applicable-device' content='pc'><meta name='keywords' content='电脑,电脑讲解,电脑技术,编程,电脑故障维修TreeMap源码分析，看了都说好' />
<script src='../../highlight/highlight.pack.js'></script>
<link rel='stylesheet' type='text/css' href='../../highlight/styles/monokai.css'/>

<link rel='stylesheet' href='../../fenxiang/dist/css/share.min.css'>
<script src='../../fenxiang/src/js/social-share.js'></script>
<script src='../../fenxiang/src/js/qrcode.js'></script>

</head><body><script>hljs.initHighlightingOnLoad();</script><script>
var system ={};  
var p = navigator.platform;       
system.win = p.indexOf('Win') == 0;  
system.mac = p.indexOf('Mac') == 0;  
system.x11 = (p == 'X11') || (p.indexOf('Linux') == 0);     
if(system.win||system.mac||system.xll){
document.write("<link href='../css/3.css' rel='stylesheet' type='text/css'>");}else{ document.write("<link href='../css/3wap.css' rel='stylesheet' type='text/css'>");}</script><script src='../../js/3.js'></script><div class='div2'><div class='heading_nav'><ul><div><li><a href='../../index.html'>首页</a></li>
</div><div onclick='hidden1()' >分享</div>
</ul></div></div>
<div id='heading_nav2'> 
<li class='row' >
<div class='social-share' data-mode='prepend'><a href='javascript:' class='social-share-icon icon-heart'></a></div></li></div><script charset='utf-8' src='../../3/js/hengfu.js'></script><script charset='utf-8' src='../../3/js/hengfu2.js'></script><hr><div class='div1'><div class='biaoti'><center>TreeMap源码分析，看了都说好</center></div><div class='banquan'>原文出处:本文由博客园博主Java博客手留余香提供。<br/>
原文连接:https://www.cnblogs.com/yuxiang1/p/11492012.html</div><br>
    <h2><span style="font-size: 16px;">概述</span></h2>
<p><span style="font-size: 16px;">TreeMap也是Map接口的实现类，它最大的特点是迭代有序，默认是按照key值升序迭代（当然也可以设置成降序）。在前面的文章中讲过LinkedHashMap也是迭代有序的，不过是按插入顺序或访问顺序，这与TreeMap需要区分开来。TreeMap内部用红黑树存储数据，而不是像HashMap、LinkedHashMap、WeakHashMap一样使用哈希表来存储。</span></p>
<p><span style="font-size: 16px;">此外，TreeMap也是非线程安全的，并且与基于哈希表实现的Map实现类不同，TreeMap的key和value值都不允许为Null。</span></p>
<h2><span style="font-size: 16px;">红黑树</span></h2>
<p><span style="font-size: 16px;">在介绍红黑树之前，先简单介绍一下排序二叉树。排序二叉树是一种特殊结构的二叉树，可以非常方便地对树中所有节点进行排序和检索。</span></p>
<p><span style="font-size: 16px;">排序二叉树可以为空树，如果它不为空，则满足以下性质：</span></p>
<ul>
<li><span style="font-size: 16px;">若它的左子树不空，则左子树上所有节点的值均小于它的根节点的值；</span></li>
<li><span style="font-size: 16px;">若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；</span></li>
<li><span style="font-size: 16px;">它的左、右子树也分别为排序二叉树。</span></li>
</ul>
<p><span style="font-size: 16px;">下图即为一个排序二叉树：</span></p>
<p><span style="font-size: 16px;"><img class="origin_image zh-lightbox-thumb lazy" src="./images/TreeMap源码分析，看了都说好0.png" alt="" width="502" data-caption="" data-size="normal" data-rawwidth="502" data-rawheight="521" data-original="https://pic3.zhimg.com/v2-224ecf1ffdc5fe0dd821bf701da3121a_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-224ecf1ffdc5fe0dd821bf701da3121a_b.jpg" data-lazy-status="ok" /></span></p>
<p><span style="font-size: 16px;">对排序二叉树，若按中序遍历就可以得到由小到大的有序序列。</span></p>
<p><span style="font-size: 16px;">排序二叉树虽然可以快速检索，但在最坏的情况下：如果插入的节点集本身就是有序的，要么是由小到大排列，要么是由大到小排列，那么最后得到的排序二叉树将变成链表：所有节点只有左节点（如果插入节点集本身是大到小排列）；或所有节点只有右节点（如果插入节点集本身是小到大排列）。在这种情况下，排序二叉树就变成了普通链表，其检索效率就会很差。</span></p>
<p><span style="font-size: 16px;">而红黑树则是对这一点进行了改进的排序二叉树，也叫&ldquo;对称二叉B树&rdquo;，它在原有的排序二叉树增加了如下几个要求：</span></p>
<ul>
<li><span style="font-size: 16px;">性质 1：每个节点要么是红色，要么是黑色。</span></li>
<li><span style="font-size: 16px;">性质 2：根节点永远是黑色的。</span></li>
<li><span style="font-size: 16px;">性质 3：所有的叶节点都是空节点（即 null），并且是黑色的。</span></li>
<li><span style="font-size: 16px;">性质 4：每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）</span></li>
<li><span style="font-size: 16px;">性质 5：从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。</span></li>
</ul>
<p><span style="font-size: 16px;">下图展示了一个红黑树，其中白色节点代表红色。</span></p>
<p><span style="font-size: 16px;"><img class="origin_image zh-lightbox-thumb lazy" src="./images/TreeMap源码分析，看了都说好1.png" alt="" width="484" data-caption="" data-size="normal" data-rawwidth="484" data-rawheight="233" data-original="https://pic3.zhimg.com/v2-c12d128119ca71d17c48a6e43e609f8e_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-c12d128119ca71d17c48a6e43e609f8e_b.jpg" data-lazy-status="ok" /></span></p>
<p><span style="font-size: 16px;">根据性质 5：红黑树从根节点到每个叶子节点的路径都包含相同数量的黑色节点，因此从根节点到叶子节点的路径中包含的黑色节点数被称为树的&ldquo;黑色高度（black-height）&rdquo;。 性质 4 则保证了从根节点到叶子节点的最长路径的长度不会超过任何其他路径的两倍。假如有一棵黑色高度为 3 的红黑树：从根节点到叶节点的最短路径长度是 2，该路径上全是黑色节点（黑节点 - 黑节点 - 黑节点）。最长路径也只可能为 4，在每个黑色节点之间插入一个红色节点（黑节点 - 红节点 - 黑节点 - 红节点 - 黑节点），性质 4 保证绝不可能插入更多的红色节点。由此可见，红黑树中最长路径就是一条红黑交替的路径。</span></p>
<p><span style="font-size: 16px;">由此我们可以得出结论：对于给定的黑色高度为 N&nbsp;的红黑树，从根到叶子节点的最短路径长度为 N-1，最长路径长度为 2 * (N-1)。</span></p>
<p><span style="font-size: 16px;">红黑树通过上面这种限制来保证它大致是平衡的&mdash;&mdash;因为红黑树的高度不会无限增高，这样保证红黑树在最坏情况下都是高效的，不会出现普通排序二叉树的情况。</span></p>
<p><span style="font-size: 16px;">在红黑树上进行插入操作和删除操作会导致树不再符合红黑树的特征，因此插入操作和删除操作都需要进行一定的维护，以保证插入节点、删除节点后的树依然是红黑树。这也是我们在阅读TreeMap源码的时候需要着重关注的部分。</span></p>
<h2><span style="font-size: 16px;">底层实现</span></h2>
<h3><span style="font-size: 16px;">实现的接口</span></h3>
<p><span style="font-size: 16px;">先来看一下TreeMap的定义：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">class</span> TreeMap&lt;K,V&gt;
    <span style="color: #0000ff;">extends</span> AbstractMap&lt;K,V&gt;
    <span style="color: #0000ff;">implements</span> NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">这里可以看到，TreeMap实现了一个NavigableMap&lt;K,V&gt;接口，该接口定义如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> NavigableMap&lt;K,V&gt; <span style="color: #0000ff;">extends</span> SortedMap&lt;K,V&gt; </code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">其继承自SortedMap&lt;K,V&gt;，该接口定义如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">interface</span> SortedMap&lt;K,V&gt; <span style="color: #0000ff;">extends</span> Map&lt;K,V&gt; </code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">顾名思义，SortedMap定义了有序的Map，这个顺序一般是指由Comparable接口提供的keys的自然序（natural ordering），也可以在创建SortedMap实例时，指定一个Comparator来决定Map的遍历顺序。</span></p>
<p><span style="font-size: 16px;">当我们在用集合视角（collection views，与HashMap一样，也是由entrySet、keySet与values方法提供）来迭代（iterate）一个SortedMap实例时会体现出key的顺序。</span></p>
<p><span style="font-size: 16px;">再申明一下关于Comparable与Comparator的区别：</span></p>
<ul>
<li><span style="font-size: 16px;">Comparable一般表示类的自然序，比如定义一个Student类，学号为默认排序；</span></li>
<li><span style="font-size: 16px;">Comparator一般表示类在某种场合下的特殊分类，需要定制化排序。比如现在想按照Student类的age来排序。</span></li>
</ul>
<p><span style="font-size: 16px;">插入SortedMap中的key的类都必须继承Comparable类（或指定一个comparator），这样才能确定如何比较（通过<code>k1.compareTo(k2)</code>或<code>comparator.compare(k1, k2)</code>）两个key，否则，在插入时，会报ClassCastException的异常。</span></p>
<p><span style="font-size: 16px;">此外，SortedMap中key的顺序性应与equals方法保持一致。也就是说<code>k1.compareTo(k2)</code>或<code>comparator.compare(k1, k2)</code>为true时，<code>k1.equals(k2)</code>也应该为true。</span></p>
<p><span style="font-size: 16px;">介绍完了SortedMap，现在再回到NavigableMap&lt;K,V&gt;上来。</span></p>
<p><span style="font-size: 16px;">NavigableMap出现于JDK 1.6，它在SortedMap的基础上，增加了一些&ldquo;导航方法&rdquo;（navigation methods）来返回与搜索目标最近的元素。例如：</span></p>
<ul>
<li><span style="font-size: 16px;"><code>lowerEntry</code>，返回所有比给定Map.Entry小的元素</span></li>
<li><span style="font-size: 16px;"><code>floorEntry</code>，返回所有比给定Map.Entry小或相等的元素</span></li>
<li><span style="font-size: 16px;"><code>ceilingEntry</code>，返回所有比给定Map.Entry大或相等的元素</span></li>
<li><span style="font-size: 16px;"><code>higherEntry</code>，返回所有比给定Map.Entry大的元素</span></li>
</ul>
<h3><span style="font-size: 16px;">底层数据结构</span></h3>
<p><span style="font-size: 16px;">先来看一下TreeMap的静态内部类Entry，它实现了红黑树的节点：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code>  <span style="color: #0000ff;">static</span> <span style="color: #0000ff;">final</span> <span style="color: #0000ff;">class</span> Entry&lt;K,V&gt; <span style="color: #0000ff;">implements</span> Map.Entry&lt;K,V&gt;<span style="color: #000000;"> {
        K key;
        V value;
        Entry</span>&lt;K,V&gt;<span style="color: #000000;"> left;
        Entry</span>&lt;K,V&gt;<span style="color: #000000;"> right;
        Entry</span>&lt;K,V&gt;<span style="color: #000000;"> parent;
        </span><span style="color: #008000;">//</span><span style="color: #008000;">节点默认为黑色</span>
        <span style="color: #0000ff;">boolean</span> color =<span style="color: #000000;"> BLACK;
        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * 传入key，value，parent参数，创建新节点，子树为null，节点颜色默认为黑色。 </span><span style="color: #008000;">*/</span><span style="color: #000000;">
        Entry(K key, V value, Entry</span>&lt;K,V&gt;<span style="color: #000000;"> parent) {
            </span><span style="color: #0000ff;">this</span>.key =<span style="color: #000000;"> key;
            </span><span style="color: #0000ff;">this</span>.value =<span style="color: #000000;"> value;
            </span><span style="color: #0000ff;">this</span>.parent =<span style="color: #000000;"> parent;
        }
        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * Returns the key. * * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the key </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span><span style="color: #000000;"> K getKey() {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> key;
        }
        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * Returns the value associated with the key. * * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the value associated with the key </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span><span style="color: #000000;"> V getValue() {
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> value;
        }
        </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * Replaces the value currently associated with the key with the given * value. * * </span><span style="color: #808080;">@return</span><span style="color: #008000;"> the value associated with the key before this method was * called </span><span style="color: #008000;">*/</span>
        <span style="color: #0000ff;">public</span><span style="color: #000000;"> V setValue(V value) {
            V oldValue </span>= <span style="color: #0000ff;">this</span><span style="color: #000000;">.value;
            </span><span style="color: #0000ff;">this</span>.value =<span style="color: #000000;"> value;
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
        }
        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">boolean</span><span style="color: #000000;"> equals(Object o) {
            </span><span style="color: #0000ff;">if</span> (!(o <span style="color: #0000ff;">instanceof</span><span style="color: #000000;"> Map.Entry))
                </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">false</span><span style="color: #000000;">;
            Map.Entry</span>&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;<span style="color: #000000;">)o;

            </span><span style="color: #0000ff;">return</span> valEquals(key,e.getKey()) &amp;&amp;<span style="color: #000000;"> valEquals(value,e.getValue());
        }

        </span><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span><span style="color: #000000;"> hashCode() {
            </span><span style="color: #0000ff;">int</span> keyHash = (key==<span style="color: #0000ff;">null</span> ? 0<span style="color: #000000;"> : key.hashCode());
            </span><span style="color: #0000ff;">int</span> valueHash = (value==<span style="color: #0000ff;">null</span> ? 0<span style="color: #000000;"> : value.hashCode());
            </span><span style="color: #0000ff;">return</span> keyHash ^<span style="color: #000000;"> valueHash;
        }

        </span><span style="color: #0000ff;">public</span><span style="color: #000000;"> String toString() {
            </span><span style="color: #0000ff;">return</span> key + "=" +<span style="color: #000000;"> value;
        }
    }</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">从代码中可以看出，一个Entry对象代表了红黑树的一个节点，其中除了存放着key-value pair的key、value值，还存放着该节点的颜色、左子节点、右子节点、父节点。</span></p>
<p><span style="font-size: 16px;">再来看一下TreeMap的重要属性：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code>    <span style="color: #008000;">//</span><span style="color: #008000;">用来它定制排序规则，当它的值为null时，则使用key的自然顺序排序</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">final</span> Comparator&lt;? <span style="color: #0000ff;">super</span> K&gt;<span style="color: #000000;"> comparator;
    </span><span style="color: #008000;">//</span><span style="color: #008000;">红黑树的根节点</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">transient</span> Entry&lt;K,V&gt;<span style="color: #000000;"> root;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * The number of entries in the tree </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">transient</span> <span style="color: #0000ff;">int</span> size = 0<span style="color: #000000;">;
    </span><span style="color: #008000;">/**</span><span style="color: #008000;"> * The number of structural modifications to the tree. </span><span style="color: #008000;">*/</span>
    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">transient</span> <span style="color: #0000ff;">int</span> modCount = 0;</code></pre>

<p>&nbsp;</p>

<h2><span style="font-size: 16px;">重要方法</span></h2>
<p><span style="font-size: 16px;">下面来看一下TreeMap中最常用的增删改查方法，它们的源码都很好地体现了红黑树的特点。</span></p>
<h3><span style="font-size: 16px;">添加节点</span></h3>
<p><span style="font-size: 16px;"><code>put</code>方法可以将一对key-value pair放到TreeMap中，当然也可以修改TreeMap中某个key对应的value值。在内部实现中，也需要将一个节点添加到红黑树中，这改变了原有红黑树的结构，因此需要做一些调整来保证修改后的树也符合红黑树的规则，让我们来看看源码中是怎么做的：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code> <span style="color: #0000ff;">public</span><span style="color: #000000;"> V put(K key, V value) {
        Entry</span>&lt;K,V&gt; t =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">if</span> (t == <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            compare(key, key); </span><span style="color: #008000;">//</span><span style="color: #008000;"> type (and possibly null) check</span>
<span style="color: #000000;">
            root </span>= <span style="color: #0000ff;">new</span> Entry&lt;&gt;(key, value, <span style="color: #0000ff;">null</span><span style="color: #000000;">);
            size </span>= 1<span style="color: #000000;">;
            modCount</span>++<span style="color: #000000;">;
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">int</span><span style="color: #000000;"> cmp;
        Entry</span>&lt;K,V&gt;<span style="color: #000000;"> parent;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> split comparator and comparable paths</span>
        Comparator&lt;? <span style="color: #0000ff;">super</span> K&gt; cpr =<span style="color: #000000;"> comparator;
        </span><span style="color: #0000ff;">if</span> (cpr != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
                parent </span>=<span style="color: #000000;"> t;
                cmp </span>=<span style="color: #000000;"> cpr.compare(key, t.key);
                </span><span style="color: #0000ff;">if</span> (cmp &lt; 0<span style="color: #000000;">)
                    t </span>=<span style="color: #000000;"> t.left;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmp &gt; 0<span style="color: #000000;">)
                    t </span>=<span style="color: #000000;"> t.right;
                </span><span style="color: #0000ff;">else</span>
                    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t.setValue(value);
            } </span><span style="color: #0000ff;">while</span> (t != <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            </span><span style="color: #0000ff;">if</span> (key == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> NullPointerException();
            @SuppressWarnings(</span>"unchecked"<span style="color: #000000;">)
                Comparable</span>&lt;? <span style="color: #0000ff;">super</span> K&gt; k = (Comparable&lt;? <span style="color: #0000ff;">super</span> K&gt;<span style="color: #000000;">) key;
            </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
                parent </span>=<span style="color: #000000;"> t;
                cmp </span>=<span style="color: #000000;"> k.compareTo(t.key);
                </span><span style="color: #0000ff;">if</span> (cmp &lt; 0<span style="color: #000000;">)
                    t </span>=<span style="color: #000000;"> t.left;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmp &gt; 0<span style="color: #000000;">)
                    t </span>=<span style="color: #000000;"> t.right;
                </span><span style="color: #0000ff;">else</span>
                    <span style="color: #0000ff;">return</span><span style="color: #000000;"> t.setValue(value);
            } </span><span style="color: #0000ff;">while</span> (t != <span style="color: #0000ff;">null</span><span style="color: #000000;">);
        }
        Entry</span>&lt;K,V&gt; e = <span style="color: #0000ff;">new</span> Entry&lt;&gt;<span style="color: #000000;">(key, value, parent);
        </span><span style="color: #0000ff;">if</span> (cmp &lt; 0<span style="color: #000000;">)
            parent.left </span>=<span style="color: #000000;"> e;
        </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
            parent.right </span>=<span style="color: #000000;"> e;
        fixAfterInsertion(e);
        size</span>++<span style="color: #000000;">;
        modCount</span>++<span style="color: #000000;">;
        </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;
    }</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;"><code>put</code>方法就是将新的Entry添加到二叉排序树上的过程，内容并不复杂，需要额外关注的是它调用的<code>fixAfterInsertion(e)</code>方法，该方法就是修复红黑树的过程，其源码如下，笔者已进行了详细地注释：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code>    <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> fixAfterInsertion(Entry&lt;K,V&gt;<span style="color: #000000;"> x) {
        x.color </span>=<span style="color: #000000;"> RED;
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 直到 x 节点的父节点不是根，且 x 的父节点不是红色</span>
        <span style="color: #0000ff;">while</span> (x != <span style="color: #0000ff;">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color ==<span style="color: #000000;"> RED) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点是其父节点的左子节点</span>
            <span style="color: #0000ff;">if</span> (parentOf(x) ==<span style="color: #000000;"> leftOf(parentOf(parentOf(x)))) {
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 x 的父节点的兄弟节点</span>
                Entry&lt;K,V&gt; y =<span style="color: #000000;"> rightOf(parentOf(parentOf(x)));
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点的兄弟节点是红色</span>
                <span style="color: #0000ff;">if</span> (colorOf(y) ==<span style="color: #000000;"> RED) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为黑色</span>
<span style="color: #000000;">                    setColor(parentOf(x), BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点的兄弟节点设为黑色</span>
<span style="color: #000000;">                    setColor(y, BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点的父节点设为红色</span>
<span style="color: #000000;">                    setColor(parentOf(parentOf(x)), RED);
                    x </span>=<span style="color: #000000;"> parentOf(parentOf(x));
                } </span><span style="color: #0000ff;">else</span> {<span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点的兄弟节点是黑色
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 是其父节点的右子节点</span>
                    <span style="color: #0000ff;">if</span> (x ==<span style="color: #000000;"> rightOf(parentOf(x))) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为 x</span>
                        x =<span style="color: #000000;"> parentOf(x);
                        rotateLeft(x);
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把 x 的父节点设为黑色</span>
<span style="color: #000000;">                    setColor(parentOf(x), BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把 x 的父节点的父节点设为红色</span>
<span style="color: #000000;">                    setColor(parentOf(parentOf(x)), RED);
                    rotateRight(parentOf(parentOf(x)));
                }
            } </span><span style="color: #0000ff;">else</span> {<span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点是其父节点的右子节点
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 x 的父节点的兄弟节点</span>
                Entry&lt;K,V&gt; y =<span style="color: #000000;"> leftOf(parentOf(parentOf(x)));
                </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点的兄弟节点是红色</span>
                <span style="color: #0000ff;">if</span> (colorOf(y) ==<span style="color: #000000;"> RED) {
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为黑色</span>
<span style="color: #000000;">                    setColor(parentOf(x), BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点的兄弟节点设为黑色</span>
<span style="color: #000000;">                    setColor(y, BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点的父节点设为红色</span>
<span style="color: #000000;">                    setColor(parentOf(parentOf(x)), RED);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 设为 x 的父节点的节点</span>
                    x =<span style="color: #000000;"> parentOf(parentOf(x));
                } </span><span style="color: #0000ff;">else</span> {<span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 的父节点的兄弟节点是黑色
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 是其父节点的左子节点</span>
                    <span style="color: #0000ff;">if</span> (x ==<span style="color: #000000;"> leftOf(parentOf(x))) {
                        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为 x </span>
                        x =<span style="color: #000000;"> parentOf(x);
                        rotateRight(x);
                    }
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把 x 的父节点设为黑色</span>
<span style="color: #000000;">                    setColor(parentOf(x), BLACK);
                    </span><span style="color: #008000;">//</span><span style="color: #008000;"> 把 x 的父节点的父节点设为红色</span>
<span style="color: #000000;">                    setColor(parentOf(parentOf(x)), RED);
                    rotateLeft(parentOf(parentOf(x)));
                }
            }
        }
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将根节点设为黑色</span>
        root.color =<span style="color: #000000;"> BLACK;
    }</span></code></pre>

<p>&nbsp;</p>

<h3><span style="font-size: 16px;">删除节点</span></h3>
<p><span style="font-size: 16px;"><code>remove(key)</code>方法就是从TreeMap中删除一对key-pair，也就是从红黑树中删除一个节点，进行该操作后也需要修复红黑树，具体代码如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> V remove(Object key) {
        Entry</span>&lt;K,V&gt; p =<span style="color: #000000;"> getEntry(key);
        </span><span style="color: #0000ff;">if</span> (p == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
            </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">;

        V oldValue </span>=<span style="color: #000000;"> p.value;
        deleteEntry(p);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> oldValue;
    }</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">其中调用的<code>deleteEntry</code>方法，主要作用就是将指定的Entry从红黑树中删除，源码如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code>   <span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> deleteEntry(Entry&lt;K,V&gt;<span style="color: #000000;"> p) {
        modCount</span>++<span style="color: #000000;">;
        size</span>--<span style="color: #000000;">;

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> If strictly internal, copy successor's element to p and then make p
        </span><span style="color: #008000;">//</span><span style="color: #008000;"> point to successor.</span>
        <span style="color: #0000ff;">if</span> (p.left != <span style="color: #0000ff;">null</span> &amp;&amp; p.right != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            Entry</span>&lt;K,V&gt; s =<span style="color: #000000;"> successor(p);
            p.key </span>=<span style="color: #000000;"> s.key;
            p.value </span>=<span style="color: #000000;"> s.value;
            p </span>=<span style="color: #000000;"> s;
        } </span><span style="color: #008000;">//</span><span style="color: #008000;"> p has 2 children

        </span><span style="color: #008000;">//</span><span style="color: #008000;"> Start fixup at replacement node, if it exists.</span>
        Entry&lt;K,V&gt; replacement = (p.left != <span style="color: #0000ff;">null</span> ?<span style="color: #000000;"> p.left : p.right);

        </span><span style="color: #0000ff;">if</span> (replacement != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Link replacement to parent</span>
            replacement.parent =<span style="color: #000000;"> p.parent;
            </span><span style="color: #0000ff;">if</span> (p.parent == <span style="color: #0000ff;">null</span><span style="color: #000000;">)
                root </span>=<span style="color: #000000;"> replacement;
            </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p ==<span style="color: #000000;"> p.parent.left)
                p.parent.left  </span>=<span style="color: #000000;"> replacement;
            </span><span style="color: #0000ff;">else</span><span style="color: #000000;">
                p.parent.right </span>=<span style="color: #000000;"> replacement;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Null out links so they are OK to use by fixAfterDeletion.</span>
            p.left = p.right = p.parent = <span style="color: #0000ff;">null</span><span style="color: #000000;">;

            </span><span style="color: #008000;">//</span><span style="color: #008000;"> Fix replacement</span>
            <span style="color: #0000ff;">if</span> (p.color ==<span style="color: #000000;"> BLACK)
                fixAfterDeletion(replacement);
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p.parent == <span style="color: #0000ff;">null</span>) { <span style="color: #008000;">//</span><span style="color: #008000;"> return if we are the only node.</span>
            root = <span style="color: #0000ff;">null</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> { <span style="color: #008000;">//</span><span style="color: #008000;"> No children. Use self as phantom replacement and unlink.</span>
            <span style="color: #0000ff;">if</span> (p.color ==<span style="color: #000000;"> BLACK)
                fixAfterDeletion(p);

            </span><span style="color: #0000ff;">if</span> (p.parent != <span style="color: #0000ff;">null</span><span style="color: #000000;">) {
                </span><span style="color: #0000ff;">if</span> (p ==<span style="color: #000000;"> p.parent.left)
                    p.parent.left </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (p ==<span style="color: #000000;"> p.parent.right)
                    p.parent.right </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
                p.parent </span>= <span style="color: #0000ff;">null</span><span style="color: #000000;">;
            }
        }
    }</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">这段代码逻辑并不复杂，但在完成删除后，也需要调用一个<code>fixAfterDeletion</code>，来修复红黑树的结构，代码如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #008000;">//</span><span style="color: #008000;"> 删除节点后修复红黑树</span>
<span style="color: #0000ff;">private</span> <span style="color: #0000ff;">void</span> fixAfterDeletion(Entry&lt;K,V&gt;<span style="color: #000000;"> x) 
{ 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 直到 x 不是根节点，且 x 的颜色是黑色</span>
   <span style="color: #0000ff;">while</span> (x != root &amp;&amp; colorOf(x) ==<span style="color: #000000;"> BLACK) 
   { 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 是其父节点的左子节点</span>
       <span style="color: #0000ff;">if</span> (x ==<span style="color: #000000;"> leftOf(parentOf(x))) 
       { 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 x 节点的兄弟节点</span>
           Entry&lt;K,V&gt; sib =<span style="color: #000000;"> rightOf(parentOf(x)); 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 节点是红色</span>
           <span style="color: #0000ff;">if</span> (colorOf(sib) ==<span style="color: #000000;"> RED) 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 节点设为黑色</span>
<span style="color: #000000;">               setColor(sib, BLACK); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为红色</span>
<span style="color: #000000;">               setColor(parentOf(x), RED); 
               rotateLeft(parentOf(x)); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 再次将 sib 设为 x 的父节点的右子节点</span>
               sib =<span style="color: #000000;"> rightOf(parentOf(x)); 
           } 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 的两个子节点都是黑色</span>
           <span style="color: #0000ff;">if</span> (colorOf(leftOf(sib)) ==<span style="color: #000000;"> BLACK 
               </span>&amp;&amp; colorOf(rightOf(sib)) ==<span style="color: #000000;"> BLACK) 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 设为红色</span>
<span style="color: #000000;">               setColor(sib, RED); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 让 x 等于 x 的父节点</span>
               x =<span style="color: #000000;"> parentOf(x); 
           } 
           </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 的只有右子节点是黑色</span>
               <span style="color: #0000ff;">if</span> (colorOf(rightOf(sib)) ==<span style="color: #000000;"> BLACK) 
               { 
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的左子节点也设为黑色</span>
<span style="color: #000000;">                   setColor(leftOf(sib), BLACK); 
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 设为红色</span>
<span style="color: #000000;">                   setColor(sib, RED); 
                   rotateRight(sib); 
                   sib </span>=<span style="color: #000000;"> rightOf(parentOf(x)); 
               } 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 设置 sib 的颜色与 x 的父节点的颜色相同</span>
<span style="color: #000000;">               setColor(sib, colorOf(parentOf(x))); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为黑色</span>
<span style="color: #000000;">               setColor(parentOf(x), BLACK); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的右子节点设为黑色</span>
<span style="color: #000000;">               setColor(rightOf(sib), BLACK); 
               rotateLeft(parentOf(x)); 
               x </span>=<span style="color: #000000;"> root; 
           } 
       } 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 x 是其父节点的右子节点</span>
       <span style="color: #0000ff;">else</span><span style="color: #000000;"> 
       { 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取 x 节点的兄弟节点</span>
           Entry&lt;K,V&gt; sib =<span style="color: #000000;"> leftOf(parentOf(x)); 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 的颜色是红色</span>
           <span style="color: #0000ff;">if</span> (colorOf(sib) ==<span style="color: #000000;"> RED) 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的颜色设为黑色</span>
<span style="color: #000000;">               setColor(sib, BLACK); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的父节点设为红色</span>
<span style="color: #000000;">               setColor(parentOf(x), RED); 
               rotateRight(parentOf(x)); 
               sib </span>=<span style="color: #000000;"> leftOf(parentOf(x)); 
           } 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 的两个子节点都是黑色</span>
           <span style="color: #0000ff;">if</span> (colorOf(rightOf(sib)) ==<span style="color: #000000;"> BLACK 
               </span>&amp;&amp; colorOf(leftOf(sib)) ==<span style="color: #000000;"> BLACK) 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 设为红色</span>
<span style="color: #000000;">               setColor(sib, RED); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 让 x 等于 x 的父节点</span>
               x =<span style="color: #000000;"> parentOf(x); 
           } 
           </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> 
           { 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 sib 只有左子节点是黑色</span>
               <span style="color: #0000ff;">if</span> (colorOf(leftOf(sib)) ==<span style="color: #000000;"> BLACK) 
               { 
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的右子节点也设为黑色</span>
<span style="color: #000000;">                   setColor(rightOf(sib), BLACK); 
                   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 设为红色</span>
<span style="color: #000000;">                   setColor(sib, RED); 
                   rotateLeft(sib); 
                   sib </span>=<span style="color: #000000;"> leftOf(parentOf(x)); 
               } 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的颜色设为与 x 的父节点颜色相同</span>
<span style="color: #000000;">               setColor(sib, colorOf(parentOf(x))); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 x 的父节点设为黑色</span>
<span style="color: #000000;">               setColor(parentOf(x), BLACK); 
               </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 sib 的左子节点设为黑色</span>
<span style="color: #000000;">               setColor(leftOf(sib), BLACK); 
               rotateRight(parentOf(x)); 
               x </span>=<span style="color: #000000;"> root; 
           } 
       } 
   } 
   setColor(x, BLACK); 
}</span></code></pre>

<p>&nbsp;</p>

<h3><span style="font-size: 16px;">查询节点</span></h3>
<p><span style="font-size: 16px;"><code>get(key)</code>方法是通过传入的key值来查找其对应的value，这一操作并不会改变红黑树的结构，源码如下：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">public</span><span style="color: #000000;"> V get(Object key) 
{ 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 根据指定 key 取出对应的 Entry </span>
   Entry&gt;K,V&lt; p =<span style="color: #000000;"> getEntry(key); 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 返回该 Entry 所包含的 value </span>
   <span style="color: #0000ff;">return</span> (p==<span style="color: #0000ff;">null</span> ? <span style="color: #0000ff;">null</span><span style="color: #000000;"> : p.value); 
}
其调用了getEntry(key)方法，该方法源码如下：

</span><span style="color: #0000ff;">final</span> Entry&lt;K,V&gt;<span style="color: #000000;"> getEntry(Object key) 
{ 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 comparator 不为 null，表明程序采用定制排序</span>
   <span style="color: #0000ff;">if</span> (comparator != <span style="color: #0000ff;">null</span><span style="color: #000000;">) 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 调用 getEntryUsingComparator 方法来取出对应的 key </span>
       <span style="color: #0000ff;">return</span><span style="color: #000000;"> getEntryUsingComparator(key); 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 key 形参的值为 null，抛出 NullPointerException 异常</span>
   <span style="color: #0000ff;">if</span> (key == <span style="color: #0000ff;">null</span><span style="color: #000000;">) 
       </span><span style="color: #0000ff;">throw</span> <span style="color: #0000ff;">new</span><span style="color: #000000;"> NullPointerException(); 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 将 key 强制类型转换为 Comparable 实例</span>
   Comparable&lt;? <span style="color: #0000ff;">super</span> K&gt; k = (Comparable&lt;? <span style="color: #0000ff;">super</span> K&gt;<span style="color: #000000;">) key; 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从树的根节点开始</span>
   Entry&lt;K,V&gt; p =<span style="color: #000000;"> root; 
   </span><span style="color: #0000ff;">while</span> (p != <span style="color: #0000ff;">null</span><span style="color: #000000;">) 
   { 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 拿 key 与当前节点的 key 进行比较</span>
       <span style="color: #0000ff;">int</span> cmp =<span style="color: #000000;"> k.compareTo(p.key); 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 key 小于当前节点的 key，向&ldquo;左子树&rdquo;搜索</span>
       <span style="color: #0000ff;">if</span> (cmp &lt; 0<span style="color: #000000;">) 
           p </span>=<span style="color: #000000;"> p.left; 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 key 大于当前节点的 key，向&ldquo;右子树&rdquo;搜索</span>
       <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmp &gt; 0<span style="color: #000000;">) 
           p </span>=<span style="color: #000000;"> p.right; 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 不大于、不小于，就是找到了目标 Entry </span>
       <span style="color: #0000ff;">else</span> 
           <span style="color: #0000ff;">return</span><span style="color: #000000;"> p; 
   } 
   </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">; 
}</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">该方法思路很简单，就是利用排序二叉树的特征来搜索key值对应的Entry，从二叉树的根节点开始，如果被搜索节点大于当前节点，程序向&ldquo;右子树&rdquo;搜索；如果被搜索节点小于当前节点，程序向&ldquo;左子树&rdquo;搜索；如果相等，那就是找到了指定节点。</span></p>
<p><span style="font-size: 16px;">此外，该方法中需要考虑用Comparator定制排序或用key的自然顺序排序两种情况，当<code>comparator != null</code>&nbsp;即采用定制排序，此时就要调用&nbsp;<code>getEntryUsingComparator(key)</code>方法：</span></p>
<src class="highlight">
<src class="cnblogs_code">
<pre><code><span style="color: #0000ff;">final</span> Entry&lt;K,V&gt;<span style="color: #000000;"> getEntryUsingComparator(Object key) 
{ 
   K k </span>=<span style="color: #000000;"> (K) key; 
   </span><span style="color: #008000;">//</span><span style="color: #008000;"> 获取该 TreeMap 的 comparator </span>
   Comparator&lt;? <span style="color: #0000ff;">super</span> K&gt; cpr =<span style="color: #000000;"> comparator; 
   </span><span style="color: #0000ff;">if</span> (cpr != <span style="color: #0000ff;">null</span><span style="color: #000000;">) 
   { 
       </span><span style="color: #008000;">//</span><span style="color: #008000;"> 从根节点开始</span>
       Entry&lt;K,V&gt; p =<span style="color: #000000;"> root; 
       </span><span style="color: #0000ff;">while</span> (p != <span style="color: #0000ff;">null</span><span style="color: #000000;">) 
       { 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 拿 key 与当前节点的 key 进行比较</span>
           <span style="color: #0000ff;">int</span> cmp =<span style="color: #000000;"> cpr.compare(k, p.key); 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 key 小于当前节点的 key，向&ldquo;左子树&rdquo;搜索</span>
           <span style="color: #0000ff;">if</span> (cmp &lt; 0<span style="color: #000000;">) 
               p </span>=<span style="color: #000000;"> p.left; 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 如果 key 大于当前节点的 key，向&ldquo;右子树&rdquo;搜索</span>
           <span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (cmp &gt; 0<span style="color: #000000;">) 
               p </span>=<span style="color: #000000;"> p.right; 
           </span><span style="color: #008000;">//</span><span style="color: #008000;"> 不大于、不小于，就是找到了目标 Entry </span>
           <span style="color: #0000ff;">else</span> 
               <span style="color: #0000ff;">return</span><span style="color: #000000;"> p; 
       } 
   } 
   </span><span style="color: #0000ff;">return</span> <span style="color: #0000ff;">null</span><span style="color: #000000;">; 
}</span></code></pre>

<p>&nbsp;</p>

<p><span style="font-size: 16px;">其具体实现与<code>getEntry</code>方法相似，只是排序方法不同。</span></p>
<h2><span style="font-size: 16px;">总结</span></h2>
<p><span style="font-size: 16px;">TreeMap内部用红黑树保存数据，迭代顺序按照key值有序，与HashMap相比效率更低，只建议在需要按序索引key值时使用，它也是非线程安全的，key和value均不能为null值。</span></p>
<p><span style="font-size: 16px;">本文是该系列的最后一篇文章，在系列文章中我们重点介绍了List接口和Map接口的几个实现类，关于Set接口，它的特点是存储内容不能重复，我们知道Map接口定义的key-value pair中的key也是不能重复的，因此可以将Map接口实现类的value用一个未赋初值的Object对象代替，即能作为Set接口的实现。实际上Set接口有三个实现类HashSet、LinkedHashSet和TreeSet，它们在底层就是分别用HashMap、LinkedHashMap、TreeMap实现的。</span></p>
<p>&nbsp;</p>
<h2>------------------------<strong>推荐阅读</strong>------------------------</h2>
<h3 class="postTitle"><a id="cb_post_title_url" class="postTitle2" title="2019年JVM最新面试题，必须收藏它" href="https://www.cnblogs.com/yuxiang1/p/11394938.html">2019年JVM最新面试题，必须收藏它</a></h3>
<h3 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yuxiang1/p/11389989.html">最全面的阿里多线程面试题，你能回答几个？</a></h3>
<h3 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yuxiang1/p/11384456.html">Java面试题：Java中的集合及其继承关系</a></h3>
<h3 class="postTitle"><a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/yuxiang1/p/11378042.html">花了近十年的时间，整理出史上最全面Java面试题</a></h3>

</div><hr><script charset='utf-8' src='../../js/sming.js'></script></body></html>